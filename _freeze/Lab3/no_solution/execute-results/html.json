{
  "hash": "2ffac2222fd2fdf12a00ca16938a3fd1",
  "result": {
    "markdown": "---\ntitle: 'Lab 3: Analyzing functions'\nauthor: \\copyright 2005 Ben Bolker, modified at some places by Alejandro Morales, Ioannis Baltzakis & Bob Douma 2021\ndate: \"October 28, 2021\"\ncache: true\nparams:\n  solution: false\n# output:\n#   bookdown::pdf_book:\n#      includes:\n#         in_header: 'preamble1.tex'\n#   word_document: default\n#   html_document:\n#     fig_caption: yes\n#     fig_height: 4.5\n#     fig_width: 5\n#     number_sections: yes\n# geometry: margin=3cm\n# fontsize: 11pt\n---\n\n\n\n\n# Learning goals\n\nIn this lab you will learn to analyse mathematical functions. This is an important step in ecological modelling. Next, we proceed with analysing and programming these functions in `R`. To do so, you will need more advanced programming skills such as for-loops, if-else statements and functions.\n\n# Getting familiar with a bestiary of functions\n\nThe models that we will be fitting to data are composed of a deterministic component and a stochastic component. The deterministic component describes the expected pattern in absence of any randomness. You are not restricted to linear functions (as in linear regression) but you can choose among different functions.\n\nRemember that functions can be purely phenomological or mechanistic (see p.21 of Bolker). Bolker mentions the following non-linear functions in his chapter about a bestiary of functions: Hyperbolic, Michaelis-Menten (=Monod or Holling type II), Holling type III, Holling type IV, negative exponential, monomolecular (=limited exponential growth), Ricker, logistic, power law, von Bertalanffy, Sheppard, Hassell, non-rectangular hyperbola.\n\n::: {.cell type='exercisebox' latex.options='{3}' hash='no_solution_cache/html/unnamed-chunk-1_07598698f170b89d92e54678f59047e7'}\n\\BeginKnitrBlock{exercisebox}\\iffalse{-123-51-125-}\\fi{}<div class=\"exercisebox\">This exercise is the first in a series of connected and sequential exercises. The dataset 'shapes.xlsx' contains six different datasets, of which only the first two wil be used in this exercise, but if you want to practice more, you can do the exercise below for the remaining four as well.\n\nTo make yourself familiar with a number of deterministic functions, you are asked to take a number of steps: read in a dataset into `R`, make plots of the first two datasets and choose at least two appropriate functions for each dataset. Next, you will explore the properties of the selected functions after which you will choose appropriate parameter values through eyeballing so you get a reasonable fit between the data and the choosen function.\n\n\n\nA pseudocode that implements this idea:\n\n1. Read the first two datasets that are in `shapes.xlsx`. Save each sheet as `.csv` file and read it in.\n\n2. Plot the datasets in different graphs in a panel plot (_hint_: `par(mfrow=c(..,..)`, and `plot`))\n\n3. Choose (at least) two appropriate functions based on the type of data or the shape of the data.\n\n    + _hint 1_: dataset 1 describes a light response curve of ten individual plants\n    + _hint 2_: dataset 2 describes the intake rate of a predator as a function of prey density\n    + _hint 3_: dataset 3 the data describe an allometric relationship\n    + _hint 4_: dataset 4 contains measurements of population size over time\n    + _hint 5_: This dataset you need to figure out for yourselves.\n    + _hint 6_: **optional** dataset 6 a species response curve (presence/absence). Fit a model that models the               probability of presence (use google to find a good one).\n\n4. Explore the properties of the selected functions in the following steps:\n\n    a. What is the value of $f(0)$ and $f'(0)$?\n\n    b. What are the limits for $x\\to\\infty$ for $f(x)$ and $f'(x)$\n\n    c. What are the limits for $x\\to-\\infty$ for $f(x)$ and $f'(x)$\n\n    d. If $f(x)$ saturates at, say the value $a$, for $x\\to\\infty$ then determine the $x$-value $x_1$ at which $f(x_1)=\\frac{a}{2}$. If $f(x)$ obtains a maximum value, find the $x$ and $y$ coordinate of the maximum.\n\n5. Choose appropriate parameter values through eyeballing so that the chosen curves more or less match the data. Eyeballing means that you knowledge on the effect of parameter values on the shape of the function (see question 4). Later we will use likelihood methods to estimate the parameter values.\n\n6. Time permitting repeat subquestions 3-5 for the other three datasets.\n</div>\\EndKnitrBlock{exercisebox}\n:::\n\n\n::: {.cell hash='no_solution_cache/html/unnamed-chunk-2_01aa2aea51df0a56f9699be4c9b52d1b'}\n\n:::\n\n\n::: {.cell type='solutionbox' latex.options='{block-green}{3}' hash='no_solution_cache/html/unnamed-chunk-3_1e4cf3d2db85bec2f257c022d5bcf93f'}\n\n:::\n\n# For loops\n\nWhen programming your data analysis, you often need to iterate over multiple elements of a collection. These elements could be rows of a `data.frame`, datasets inside a `list`, numbers inside a vector, etc. The iteration usually means that you apply the same code over each element of the collection and you don't want to \"copy-paste\" the code for each element. Iterating over a collection is called a \"for loop\" in programming. A for loop consists of three components:\n\n1.  A collection over which you want to iterate.\n\n2.  A variable that keeps track of where you are in the collection in each iteration\n\n3.  The body of the loop where you apply some code.\n\nImagine that you want to calculate the factorial of 10. The factorial of a number is simply the product of all positive numbers smaller or equal than the number you specify (and it is denote with a \"!\" after the number). For example, the factorial of 3 is $3! = 3 \\times 2 \\times 1$. A simple way of calculating the factorial of 10 by using a for loop is:\n\n\n::: {.cell hash='no_solution_cache/html/unnamed-chunk-4_d52761d11b3228ea44270a1a4d3122d5'}\n\n```{.r .cell-code}\nresult = 1\nfor(i in 1:10) {\n  result = result*i\n}\n```\n:::\n\n\nIn this for loop, the collection is `1:10`, the variable to keep track of the number is `i` and the body of the loop is `result = result*i`. This for loop shows a very typical pattern: we want to summarise some collection of numbers into a single number, in this case, `result`.\n\nAnother typical pattern is when we want to calculate the elements of a collection. In this case, it is a good practice to \"pre-allocate\" your output collection before looping, so `R` knows how much memory to allocate for this vector. For example,\n\n\n::: {.cell hash='no_solution_cache/html/unnamed-chunk-5_97c9379d04e840882ed7376aab896509'}\n\n```{.r .cell-code}\nx = 1:10\ny = numeric(10)\nfor(i in 1:10) {\n  y[i] = exp(x[i])\n}\n```\n:::\n\n\nIn this case, the result of the for loop (`y`) is a collection of 10 elements where each element is the exponential transformation of the element in x with the same position. Note that we specify before the loop that `y` will have 10 elements. Although this is not strictly required in this case, it is a good practice both to avoid errors and to make your code run faster.\n\nFor loops are not that common in `R` as in other languages The reason is that many mathematical and statistical functions are already, implicitly, looping over your collections. For examples, when you take the exponential (`exp()`) of a collection of numbers, it will produce a new collection which is the result of looping over the original collection. That is:\n\n\n::: {.cell hash='no_solution_cache/html/unnamed-chunk-6_f305ed1094289090a6f56d645a9a08c0'}\n\n```{.r .cell-code}\nx = 1:10\ny = exp(x)\n```\n:::\n\n\nis equivalent to the previous loop described before. As you can see, this second option requires less code and it is easier to read, which is one of the reasons why `R` is such a greate language for working with data. In addition, if you rely on this implicit looping your code will run much faster.\n\nHowever, there may be situations where you really cannot avoid a for loop. For example, if you have collected multiple datasets and need to perform the same analysis on each dataset, you could store your datasets in a list and use a for loop to iterate over the different datasets.\n\n::: {.cell type='exercisebox' latex.options='{3}' hash='no_solution_cache/html/unnamed-chunk-7_987e0240cec2725f7cccb32944019eb5'}\n\\BeginKnitrBlock{exercisebox}\\iffalse{-123-51-125-}\\fi{}<div class=\"exercisebox\">Calculate the logarithm of the sequence 1:10, using first a for loop and then without a for loop.</div>\\EndKnitrBlock{exercisebox}\n:::\n\n::: {.cell type='solutionbox' latex.options='{block-green}{3}' hash='no_solution_cache/html/unnamed-chunk-8_b70ad2fbcbf9f9edcc5a036f6033b329'}\n\n:::\n\n# Missing values (NA)\n\nMissing values in data collection and analysis deserve special attention. You can get missing values during you data collection for various reasons, e.g. you missed the opportunity to take a measurement, you lose one of the replicates due to contamination, you wrote down a wrong value, or you even lost some of your data.\n\nThe most important thing you need to understand, is that in almost all cases of a missing value, you should **not represent a missing value with a zero (0)**. This will throw your analysis out of balance and give erroneous results. A common way of representing missing data when you are performing data input, would be with a character like an asterisk (\\*) or a hyphen (-).\n\nMany of the functions that read data in `R` have an argument that allows you to select how you have represented a missing-value in your data. As an example the function **read.csv** (which reads a comma-delimited data file) would be used like this to read from a file named \"your-data-file\":\n\n\n::: {.cell hash='no_solution_cache/html/unnamed-chunk-9_934179621c5265ac69e0ff4547819f5c'}\n\n```{.r .cell-code}\nmyData <- read.csv(\"you-data-file\", na.strings=c(\"*\",\"-\") )\n```\n:::\n\n\nIn this case we instructed `R`, with the argument **`na.strings=c(\"*\",\"_\")`** to read our file, and substitute any occurence of an asterisk (\\*) or a hyphen(-) with an `NA` symbol.\n\nThe `R` languages has a special way of representing missing values in a dataset. A missing value is denoted with the symbol `NA` which stands for \"**N**ot **A**vailable\". By default, missing values will \"propagate\" throughout the calculations. For example, given two vectors of data:\n\n\n::: {.cell hash='no_solution_cache/html/unnamed-chunk-10_2a6532810f782e0a66b4a7ed71b3fbee'}\n\n```{.r .cell-code}\nx = c(1,2,3)\ny = c(2,4,NA)\n```\n:::\n\n\nWhen you combine these vectors (e.g. add them or multiply them) you will see that the third component is always `NA`\n\n\n::: {.cell hash='no_solution_cache/html/unnamed-chunk-11_81642a76df353720eaa6303808862929'}\n\n```{.r .cell-code}\nx + y\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  3  6 NA\n```\n:::\n\n```{.r .cell-code}\nx*y\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  2  8 NA\n```\n:::\n:::\n\n\nWhen you calculate some statistical property of your data (e.g. mean, standard deviation) it will, by default, report `NA` if there is at least one missing value in your data\n\n\n::: {.cell hash='no_solution_cache/html/unnamed-chunk-12_573d6f363fff057dba9bc9e5ed9002fb'}\n\n```{.r .cell-code}\nmean(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2\n```\n:::\n\n```{.r .cell-code}\nmean(y)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] NA\n```\n:::\n:::\n\n\nMost statistical functions in `R` allow you to specify how to deal with missing values. Most often, you are given the option to ignore any missing values from the data when calculating an statistical property through an argument often called `na.rm`. For example, in order to get the mean of the non-missing values of `y` we need:\n\n\n::: {.cell hash='no_solution_cache/html/unnamed-chunk-13_a002eedd43c76e712a8c09744b34f804'}\n\n```{.r .cell-code}\nmean(y, na.rm = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3\n```\n:::\n:::\n\n\nwhich, of course, is the mean of 2 and 4. However, other functions not have an option to handle `NA` even though you still need to make a decision on how to deal with them. For example, when you calculate the length of a dataset (`length()`) do you want to consider the whole data or only the non-missing values? This is not a trivial question and the answer on the context where you will use the result. In any case, if you want to remove the `NA` when calculating the length you need to be more creative. Fortunately, `R` offers the function `is.na` which returns a vector of TRUE or FALSE values corresponding to the index of mssing or non-missing data values in the vector `y`:\n\n\n::: {.cell hash='no_solution_cache/html/unnamed-chunk-14_2f732a391ef403ada8a5bec19da1a3c5'}\n\n```{.r .cell-code}\nis.na(y)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE FALSE  TRUE\n```\n:::\n:::\n\n\nNext a vector without NA can be obtained through:\n\n\n::: {.cell hash='no_solution_cache/html/unnamed-chunk-15_1e3769d18547b2f15041d10d15d75119'}\n\n```{.r .cell-code}\nlength(y[!is.na(y)])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2\n```\n:::\n:::\n\n\nWhich only gives 2 as the third element is missing. Remember that `!` is a negation operator, so `!is.na` actually means \"is not NA\".\n\nBy the way, you should not confuse `NA` with `NaN` which stands for \"**N**ot **a** **N**umber\". An `NaN` is the result of either an expression with indeterminate form (e.g. `0/0` or `Inf/Inf`) or when a function is evaluated outside of its valid domain (e.g. `sqrt(-1)` or `log(-1)`).\n\n::: {.cell type='exercisebox' latex.options='{3}' hash='no_solution_cache/html/unnamed-chunk-16_08b90a6a54747820faae7659d5522123'}\n\\BeginKnitrBlock{exercisebox}\\iffalse{-123-51-125-}\\fi{}<div class=\"exercisebox\">Given some data created from the following code `c(25,1,10,89, NA, NA)`,\ncalculate the mean value and the standard error of this mean ($s.e.m. = \\sigma/\\sqrt{n}$, where $\\sigma$ is the standard deviation and $n$ is the number of items) by ignoring missing values.</div>\\EndKnitrBlock{exercisebox}\n:::\n\n::: {.cell type='solutionbox' latex.options='{block-green}{3}' hash='no_solution_cache/html/unnamed-chunk-17_aef73c188c1b3e45e63921729cb3612b'}\n\n:::\n\n# Making a function\n\nWhen you want to repeat a calculation for different data, it is best to code your calculations inside a function. `R` consists of many built-in functions, but sometimes you need to do a calculation that is not available in `R`. A function is defined by 4 elements\n\n1.  The name of the function. For example, in `R` there is a function that calculates the arithmetic mean of a vector of data and its name is `mean`. You should make sure that the name of your function does not coincide with existing functions, that it is not too long and that it conveys its meaning. You can check if a function already exist in the base or any of the packages you loaded through `?nameoffunction`.\n\n2.  The arguments of the function. These are the variables that you need to pass to the function (i.e., inputs). The arguments are defined by a position and a name. Also, some arguments may have default values which means that you do not need to specify them every time you call the function. For example, the function `mean`, contains three arguments (`x`, `trim` and `na.rm`) but the last two have default values.\n\n3.  The body of the function. This is the actual code that the function will execute. The real `mean` function in R has some crytpic body that requires advanced knowledge of the language to understand. However, a more \"naive\" implementation of `mean` could be `sum(x)/length(x)`. Note that the body of a function can consist of multiple lines.\n\n4.  The return value of the function. This is the result of applying the function on the arguments. By default, the result of the last line code in the body of the function is the return value of the function. You can also return from any point in the body with the function `return()` with the variable you want to return inside.\n\nThe `R` language specifies a particular syntax on how to build a function. For example, a `naive_mean` could be defined as:\n\n\n::: {.cell hash='no_solution_cache/html/unnamed-chunk-18_735d63607bc79e90f2f0f5a85dd4326d'}\n\n```{.r .cell-code}\nnaive_mean = function(x, na.remove = FALSE) {\n  total = sum(x, na.rm = na.remove)\n  n = length(x[!is.na(x)])\n  result = total/n\n  return(result)\n}\n```\n:::\n\n\nIn this case, the function `naive_mean` has two arguments (`x` and `na.remove`) where the second argument has a default value of FALSE and the body consists of several lines of code. These are respectively the sum of the elements of `x` with the `na.rm` depending on whether you specified TRUE or FALSE in the `na.remove` argument; `n` that calculates the length of the vector x without NAs, and the calculation of the mean. The last statement returns the result. Notice that arguments are separated by commas and the body of the function is enclosed in curly braces `{}`. The name of the function is simply the name of the variable to which you assigned the function (i.e., `naive_mean`). You can see below that you can use this function in a similar manner to the built-in `mean`\n\n\n::: {.cell hash='no_solution_cache/html/unnamed-chunk-19_a4fc83d13f60b9d32bc02460535c6ba7'}\n\n```{.r .cell-code}\nx = 1:10\nnaive_mean(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5.5\n```\n:::\n:::\n\n\nNotice that we did not specify the value of `na.remove` as the default is ok in this case. However, if we had missing values, the NA would propagate to the output:\n\n\n::: {.cell hash='no_solution_cache/html/unnamed-chunk-20_3f54bd9f343a9d6ce858439b409529d8'}\n\n```{.r .cell-code}\nx = c(1,2,NA,4)\nnaive_mean(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] NA\n```\n:::\n:::\n\n\nSpecifying `na.remove=FALSE` can be used as a double check that there are no NAs in your vector. If they are present it forces us to make a decision about what to do with the NAs. Let's say that, for the moment, we want to just remove the values that are NA from the calculation. In this case, we just change the value of the default parameter.\n\n\n::: {.cell hash='no_solution_cache/html/unnamed-chunk-21_6dba455d76058a1b9e860956aae8c6ee'}\n\n```{.r .cell-code}\nnaive_mean(x, na.remove = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2.333333\n```\n:::\n:::\n\n\nFor convenience, default parameters are specified by name rather than position. However we could have also said `naive_mean(x,TRUE)` or even `naive_mean(x = x, na.remove = TRUE)`. All these forms of calling functions are OK, whether you choose one style or another is a matter of taste.\n\n::: {.cell type='exercisebox' latex.options='{3}' hash='no_solution_cache/html/unnamed-chunk-22_5a332e4ac901b1d9c41911cae3b3edb3'}\n\\BeginKnitrBlock{exercisebox}\\iffalse{-123-51-125-}\\fi{}<div class=\"exercisebox\">Build a function to calculate the standard deviation ($\\sigma = \\sqrt{\\frac{\\sum_{i = 1}^n\\left(x_i - \\bar x\\right)^2}{n - 1}}$). Test your function with some data that includes missing values, and compare to the built in function for the standard deviation `sd`.</div>\\EndKnitrBlock{exercisebox}\n:::\n\n::: {.cell type='solutionbox' latex.options='{block-green}{3}' hash='no_solution_cache/html/unnamed-chunk-23_fde825ec15fa29ce9d2ef1a2d59c6c77'}\n\n:::\n\nSuprisingly the base `R` does not have a built in function for the standard error of the mean (s.e.m.). The sem is defined as $\\frac{\\sigma}{\\sqrt(n)}$.\n\n::: {.cell type='exercisebox' latex.options='{3}' hash='no_solution_cache/html/unnamed-chunk-24_5a8144bbd89c06eef68ed8eb5eab3f1f'}\n\\BeginKnitrBlock{exercisebox}\\iffalse{-123-51-125-}\\fi{}<div class=\"exercisebox\">Make you own function for the sem and use your own home-made function of the standard deviation for that.</div>\\EndKnitrBlock{exercisebox}\n:::\n\n::: {.cell type='solutionbox' latex.options='{block-green}{3}' hash='no_solution_cache/html/unnamed-chunk-25_207a25db08b9b78a0773ef3384a66142'}\n\n:::\n\nAs you see you can call functions inside functions. It is recommended to divide the work you want to do into little functions that each carry out a specific task, and then combine those functions into a larger function that combines these tasks. This facilitates error checking.\n\n# Numerical explorations: plotting curves\n\nHere are the `R` commands used to generate Figure 3.2 in the book (p 74). They just use `curve()`, with `add=FALSE` (the default, which draws a new plot) and `add=TRUE` (adds the curve to an existing plot), particular values of `from` and `to`, and various graphical parameters (`ylim`, `ylab`, `lty`).\n\n\n::: {.cell hash='no_solution_cache/html/unnamed-chunk-26_75f4cdc523e7c47e58665cea3279a817'}\n\n```{.r .cell-code}\ncurve(2*exp(-x/2),from=0,to=7,ylim=c(0,2),ylab=\"\")\ncurve(2*exp(-x),add=TRUE,lty=4)\ncurve(x*exp(-x/2),add=TRUE,lty=2)\ncurve(2*x*exp(-x/2),add=TRUE,lty=3)\ntext(0.4,1.9,expression(paste(\"exponential: \",2*e^(-x/2))),adj=0)\ntext(4,.5,expression(paste(\"Ricker: \",x*e^(-x/2))))\ntext(4,1,expression(paste(\"Ricker: \",2*x*e^(-x/2))),adj=0)\ntext(2.8,0,expression(paste(\"exponential: \",2*e^(-x))))\n```\n:::\n\n\nThe only new thing in this figure is the use of `expression()` to add a mathematical formula to an `R` graphic. `text(x,y,\"x^2\")` puts `x^2` on the graph at position $(x,y)$; `text(x,y,expression(x^2))` (no quotation marks) puts $x^2$ on the graph. See `?plotmath` or `?demo(plotmath)` for (much) more information.\n\nAn alternate way of plotting the exponential parts of this curve:\n\n\n::: {.cell hash='no_solution_cache/html/unnamed-chunk-27_a9005d1ed82901749c736062295694bf'}\n\n```{.r .cell-code}\nxvec = seq(0,7,length=100)\nexp1_vec = 2*exp(-xvec/2)\nexp2_vec = 2*exp(-xvec)\n```\n:::\n\n::: {.cell hash='no_solution_cache/html/unnamed-chunk-28_7f9125dac65efe60019f875d4f6a6117'}\n\n```{.r .cell-code}\nplot(xvec,exp1_vec,type=\"l\",ylim=c(0,2),ylab=\"\")\nlines(xvec,exp2_vec,lty=4)\n```\n:::\n\n\nFinally, if you have a more complicated function you could use `sapply()` to call this function along with appropriate parameter values. you could say:\n\n\n::: {.cell hash='no_solution_cache/html/unnamed-chunk-29_379cf8403e7f8248708f465fdf390f53'}\n\n```{.r .cell-code}\nexpfun = function(x,a=1,b=1) {\n   a*exp(-b*x)\n }\nexp1_vec = sapply(xvec,expfun,a=2,b=1/2)\nexp2_vec = sapply(xvec,expfun,a=2,b=1)\n```\n:::\n\n\nThe advantage of `curve()` is that you don't have to define any vectors: the advantage of doing things the other way arises when you want to keep the vectors around to do other calculations with them.\n\n::: {.cell type='exercisebox' latex.options='{3}' hash='no_solution_cache/html/unnamed-chunk-30_67424cfe3a28c8649fde0156597a7a5a'}\n\\BeginKnitrBlock{exercisebox}\\iffalse{-123-51-125-}\\fi{}<div class=\"exercisebox\">Construct a curve\nthat has a maximum at ($x=5$, $y=1$).  Write the\nequation, draw the curve in `R`, and explain\nhow you got there.</div>\\EndKnitrBlock{exercisebox}\n:::\n\n::: {.cell type='solutionbox' latex.options='{block-green}{3}' hash='no_solution_cache/html/unnamed-chunk-31_09a3579176c00e65f5458cc707f7f06c'}\n\n:::\n\n# A quick digression: `ifelse()` for piecewise functions\n\nThe `ifelse()` command in `R` is useful for constructing piecewise functions. Its basic syntax is `ifelse(condition,value_if_true,value_if_false)`, where `condition` is a logical vector (e.g. `x>0`), `value_if_true` is a vector of alternatives to use if `condition` is `TRUE`, and `value_if_false` is a vector of alternatives to use if `condition` is `FALSE`. If you specify just one value, it will be expanded (*recycled* in `R` jargon) to be the right length. A simple example:\n\n\n::: {.cell hash='no_solution_cache/html/unnamed-chunk-32_a5a7c6f7a24ce97e39c7858f88a73aa4'}\n\n```{.r .cell-code}\nx=c(-25,-16,-9,-4,-1,0,1,4,9,16,25)\nsqrt(ifelse(x<0,0,x))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 0 0 0 0 0 0 1 2 3 4 5\n```\n:::\n:::\n\n\nif you said `ifelse(x<0,0,sqrt(x)))` you would get a warning: why)\n\nHere are some examples of using `ifelse()` to generate (1) a simple threshold; (2) a Holling type I or \"hockey stick\"; (3) a more complicated piecewise model that grows exponentially and then decreases linearly; (4) a double-threshold model. When plotting functions with abrubt changes with the function `curve`, beware that curve draws a line by evaluating a functions at several locations along the specified interval (`from`, `to`). You can increase these number of points by specifying `n`. The default value for `n` is 101.\n\n\n::: {.cell fig='true' hash='no_solution_cache/html/unnamed-chunk-33_159b349197cc610d2ed816bfdfb19135'}\n\n```{.r .cell-code}\nop=par(mfrow=c(2,2),mgp=c(2,1,0),mar=c(4.2,3,1,1))\ncurve(ifelse(x<2,1,3),from=0,to=5)\ncurve(ifelse(x<2,2*x,4),from=0,to=5)\ncurve(ifelse(x<2,exp(x),exp(2)-3*(x-2)),from=0,to=5)\ncurve(ifelse(x<2,1,ifelse(x<4,3,5)),from=0,to=5)\n```\n\n::: {.cell-output-display}\n![](no_solution_files/figure-html/unnamed-chunk-33-1.png){width=672}\n:::\n:::\n\n\nThe double-threshold example (nested `ifelse()` commands) probably needs more explanation. In words, this command would go \"if $x$ is less than 2, set $y$ to 1; otherwise ($x \\ge 2$), if $x$ is less than 4 (i.e. $2 \\le x<4$), set $y$ to 3; otherwise ($x \\ge 4$), set $y$ to 5\".\n\n# Evaluating derivatives in `R`\n\n`R` can evaluate derivatives, but it is not very good at simplifying them. In order for `R` to know that you really mean (e.g) `x^2` to be a mathematical expression and not a calculation for `R` to try to do (and either fill in the current value of `x` or give an error that `x` is undefined), you have to specify it as `expression(x^2)`; you also have to tell `R` (in quotation marks) what variable you want to differentiate with respect to:\n\n\n::: {.cell hash='no_solution_cache/html/unnamed-chunk-34_de8730cdb9c00f9119bb1cc667890ca2'}\n\n```{.r .cell-code}\nd1 = D(expression(x^2),\"x\"); d1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n2 * x\n```\n:::\n:::\n\n\nUse `eval()` to fill in a list of particular values for which you want a numeric answer:\n\n\n::: {.cell hash='no_solution_cache/html/unnamed-chunk-35_d933fe506098f87d52c39a0141995238'}\n\n```{.r .cell-code}\neval(d1,list(x=2))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4\n```\n:::\n:::\n\n\nTaking the second derivative:\n\n\n::: {.cell hash='no_solution_cache/html/unnamed-chunk-36_081504fa67026070f7b92e60e618a9fe'}\n\n```{.r .cell-code}\nD(d1,\"x\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2\n```\n:::\n:::\n\n\n(As of version 2.0.1,) `R` knows how to take the derivatives of expressions including all the basic arithmetic operators; exponentials and logarithms; trigonometric inverse trig, and hyperbolic trig functions; square roots; and normal (Gaussian) density and cumulative density functions; and gamma and log-gamma functions. You're on your own for anything else (consider using a symbolic algebra package like Mathematica or Maple, at least to check your answers, if your problem is very complicated). `deriv()` is a slightly more complicated version of `D()` that is useful for incorporating the results of differentiation into functions: see the help page.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}