{
  "hash": "647d5d1bb4ea70a2c1be97c0d6f300f3",
  "result": {
    "markdown": "---\ntitle: \"Exploratory data analysis and graphics (lab 2)\"\nauthor: \\copyright 2005 Ben Bolker, modified at several places by Bob Douma\ndate: \"10 October 2019\"\ncache: true\n# output:\n#   bookdown::pdf_book:\n#      includes:\n#         in_header: 'preamble1.tex'\n  #  includes:\n  #      in_header: 'preamble.tex'\n  #pdf_document:\n  #  fig_caption: yes\n  #  fig_width: 5\n  #  number_sections: yes\n#   word_document: default\n#   html_document:\n#     fig_caption: yes\n#     fig_height: 4.5\n#     fig_width: 5\n#     number_sections: yes\n# geometry: margin=3cm\n# fontsize: 11pt\n---\n\n::: {.cell hash='index_cache/html/unnamed-chunk-1_cc8e93cb50c71ca0f21fc3f66c4bad38'}\n\n:::\n\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-2_aa214e92ec9864e0c9cd1cc1793b156c'}\n\n```{.r .cell-code}\nlibrary(emdbook)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: package 'emdbook' was built under R version 4.3.1\n```\n:::\n:::\n\n\n# Learning outcomes\n\nThis lab will teach you how 1) to read in data and reshape it so it matches your needs, and 2) to make different types of graphs that you need for data exploration and presentation purposes. It does so by reproducing the figures shown in Chapter 2 and more. The exercises, which will be more difficult than those in Lab 1, will typically involve variations on the figures shown in the text. You will work through reading in the different data sets and constructing the figures shown, or variants of them. It would be even better to work through reading in and making exploratory plots of your own data.\n\n# Read in and reshape data\n\n## Reading data\n\nFind the file called `seedpred.dat`. It is in the right format (plain text, long format), so you can just read it in with\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-3_b6f2006b3ed0b29ebba0ac31b05ea8f7'}\n\n```{.r .cell-code}\ndata = read.table(\"seedpred.dat\", header = TRUE)\n```\n:::\n\n\nAdd the variable `available` to the data frame by combining taken and remaining (using the \\$ symbol):\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-4_aace78fad980cc1c1efd572025ac1891'}\n\n```{.r .cell-code}\ndata$available = data$taken + data$remaining\n```\n:::\n\n\n*Pitfall #1: finding your file* If `R` responds to your `read.table()` or `read.csv()` command with an error like\n\n`Error in file(file, \"r\") : unable to open connection In addition: Warning message: cannot open file 'myfile.csv'`\n\nit means it can't find your file, probably because it isn't looking in the right place. By default, R's working directory is the directory in which the R program starts up, which is by default something like `C:/Program Files/R/rw2010/bin.` (`R` uses / as the \\[operating-system-independent\\] separator between directories in a file path.) If you are using Rstudio, go to 'Session' and click 'Set working directory'. You can also use the `setwd()` command to set the working directory. `getwd()` tells you what the current working directory is. While you could just throw everything on your desktop, it's good to get in the habit of setting up a separate working directory for different projects, so that your data files, metadata files, `R` script files, and so forth, are all in the same place. Depending on how you have gotten your data files onto your system (e.g. by downloading them from the web), Windows will sometimes hide or otherwise screw up the extension of your file (e.g. adding .txt to a file called `mydata.dat`). `R` needs to know the full name of the file, including the extension.\n\nFor example to set a working directory:\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-5_eb5c0f7b3c22f4c1a09a71bd810277cb'}\n\n```{.r .cell-code}\nsetwd(\"D:/Bolker/labs/\")\n```\n:::\n\n\n*Pitfall #2: checking number of fields* In some cases the number of fields is not the same for every line in your data file. In that case you may get an error like:\n\n`Error in read.table(file = file, header = header, sep = sep, quote = quote, : more columns than column names`\n\nor\n\n`Error in scan(file = file, what = what, sep = sep, quote = quote, dec = dec, : line 1 did not have 5 elements`\n\nIf you need to check on the number of fields that R thinks you have on each line, use\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-6_92d072629cdfc8102869b93db3e95a21'}\n\n```{.r .cell-code}\ncount.fields(\"myfile.dat\",sep=\",\")\n```\n:::\n\n\n(you can omit the `sep=\",\"` argument if you have whitespace- rather than comma delimited data). If you are checking a long data file you can try\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-7_09f24fe717866c3293627141674188e1'}\n\n```{.r .cell-code}\ncf = count.fields(\"myfile.dat\",sep=\",\")\nwhich(cf!=cf[1])\n```\n:::\n\n\nto get the line numbers with numbers of fields different from the first line. By default `R` will try to fill in what it sees as missing fields with `NA` (\"not available\") values; this can be useful but can also hide errors. You can try\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-8_11fc822ac68c9c8778fa495db6b32d39'}\n\n```{.r .cell-code}\nmydata <- read.csv(\"myfile.dat\", fill = FALSE)\n```\n:::\n\n\nto turn off this behavior; if you don't have any missing fields at the end of lines in your data this should work.\n\nIf your file is a comma separated file, you can also use `read.csv`. This function has set some arguments to default, e.g. the seperator is a comma in this case (`sep=\",\"`)\n\n*Pitfall #3: List separator* It may happen when you save a file in excel as `.csv` that the decimals are not indicated by a dot `.` but by a comma `,` and that the list separator is a semi-colon. To avoid this happen change the regional settings in your computer (control panel) to American or English, or change the list separator and the decimal symbol manually.\n\n## Checking data\n\nR will automatically recognize the type of data of the columns that are read in, but sometimes it goes wrong. To check that all your variables have been classified correctly:\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-9_7f8006ab0d7b94c5c2f50626e5c55c59'}\n\n```{.r .cell-code}\nsapply(data, class)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    species        tcum        tint   remaining       taken   available \n\"character\"   \"integer\"   \"integer\"   \"integer\"   \"integer\"   \"integer\" \n```\n:::\n:::\n\n\nThis applies the `class()` command, which identifies the type of a variable, to each column in your data. Alternatively,\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-10_7176330b609f2f9fe001efa834a86a89'}\n\n```{.r .cell-code}\nsummary(data)\n```\n:::\n\n\ncan be very helplful to get a glance of the characteristics of the data.\n\nNon-numeric missing-variable strings (such as a star, \\*) will also make `R` misclassify. Use `na.strings` in your `read.table()` command:\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-11_dc843efa1e0da22f9acbe136af8a4489'}\n\n```{.r .cell-code}\nmydata <- read.table(\"mydata.dat\", na.strings = \"*\")\n```\n:::\n\n\nYou can specify more than one value with (e.g.) na.strings=c(\"*\",\"*\\*\\*\",\"bad\",\"-9999\").\n\n::: {.cell type='exercisebox' latex.options='{2}' hash='index_cache/html/unnamed-chunk-12_ec0979c61f87df727d816021e3f6d185'}\n\\BeginKnitrBlock{exercisebox}\\iffalse{-123-50-125-}\\fi{}<div class=\"exercisebox\">Try out `head()`, `summary()` and `str()` on data; make sure\nyou understand the results. </div>\\EndKnitrBlock{exercisebox}\n:::\n\n::: {.cell type='solutionbox' latex.options='{block-green}{2}' hash='index_cache/html/unnamed-chunk-13_0bfa90b25e8e9a774049585e62892e4b'}\n\\BeginKnitrBlock{solutionbox}\\iffalse{-123-98-108-111-99-107-45-103-114-101-101-110-125-123-50-125-}\\fi{}<div class=\"solutionbox\">`head()` gives the first five rows of your data and are used to inspect whether the read-in procedure went ok. For example, you can see whether the header is really a header or whether is was read-in as the first data row.\n\n`summary()` gives you a summary view of your data.frame, reporting the mean and quantiles of your data, and numbers of NAs.\n\n`str()` shows you the structure and data types that are in the data.frame or other `R` objects. `str()` can be convenient to check if the data types are as you want to have them, or to extract information from complex `R` objects such as a model object fitted with `lm`.\n</div>\\EndKnitrBlock{solutionbox}\n:::\n\n## Reshaping data\n\nReshaping a dataframe is an important part of data exploration. For example, for making field recordings it is convenient to have the measurements of different plots or transects in different columns on your sheet. This is called a wide format. However, for data analysis in R (and other statistical programs) you need to have all measurements in one column, with an additional column indicating which plot a measurement belongs to (so called long format).\n\nBelow we create a dataframe in long format and reshape it. Here are the commands to generate the data frame I used as an example in the text (I use `LETTERS`, a built-in vector of the capitalized letters of the alphabet, and `runif()`, which picks a specified number of random numbers from a uniform distribution between 0 and 1. The command `round(x,3)` rounds `x` to 3 digits after the decimal place.):\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-14_93ad623f2d3b9ae196268751e7b68308'}\n\n```{.r .cell-code}\nloc = factor(rep(LETTERS[1:3],2))\nday = factor(rep(1:2,each=3))\nval = round(runif(6),3)\nd = data.frame(loc,day,val)\n```\n:::\n\n\nThis data set is stored in long format. To go to wide format, we first need to (install and) load the library `reshape2`. In Lab 1 you learned how to install packages. You can load a package by `library()` or `require()`. Thus to use an additional package it must be (i) installed on your machine (with `install.packages())` or through the menu system and (ii) loaded in your current `R` session (with `library()`):\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-15_9cf58d54a44ff811b6c4100215f2f705'}\n\n```{.r .cell-code}\nlibrary(reshape2)  \n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: package 'reshape2' was built under R version 4.3.1\n```\n:::\n\n```{.r .cell-code}\nd2 = dcast(d,loc~day )\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nUsing val as value column: use value.var to override.\n```\n:::\n\n```{.r .cell-code}\nd2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  loc     1     2\n1   A 0.922 0.027\n2   B 0.065 0.511\n3   C 0.708 0.856\n```\n:::\n:::\n\n\nloc\\~day specifies that `loc` will be used as rows and `day` will be put into columns.\n\nTo go back to long format, we simply write:\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-16_dc4415c665f9526aad6fa20c6545a1e9'}\n\n```{.r .cell-code}\nmelt(d2, variable.name=\"day\")\n```\n:::\n\n\nBy specifying the `variable.name` to `day`, we put the columns (`1` and `2`) into a new column called `day`. The column in which the values are stored can be set by using the argument `value.name`\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-17_bee8dadaf16b8a39ae3071d652513c6c'}\n\n```{.r .cell-code}\nmelt(d2, variable.name=\"day\",value.name=\"val\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nUsing loc as id variables\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n  loc day   val\n1   A   1 0.922\n2   B   1 0.065\n3   C   1 0.708\n4   A   2 0.027\n5   B   2 0.511\n6   C   2 0.856\n```\n:::\n:::\n\n\n::: {.cell type='exercisebox' latex.options='{2}' hash='index_cache/html/unnamed-chunk-18_a61e3c48a1d7f0b1aa0ea41a19524a87'}\n\\BeginKnitrBlock{exercisebox}\\iffalse{-123-50-125-}\\fi{}<div class=\"exercisebox\">Make a new data.frame similar to the previous data.frame `d`, but with an extra column `month` consisting of two levels. The value of month should be 1 for the first records and 2 for the second. Next, reshape to wide format and back to long format. The long format is what we commonly use in statistics.</div>\\EndKnitrBlock{exercisebox}\n:::\n\n::: {.cell type='solutionbox' latex.options='{block-green}{2}' hash='index_cache/html/unnamed-chunk-19_1ab877da91088333703738cde559d7b5'}\n\\BeginKnitrBlock{solutionbox}\\iffalse{-123-98-108-111-99-107-45-103-114-101-101-110-125-123-50-125-}\\fi{}<div class=\"solutionbox\">`loc = factor(rep(LETTERS[1:3],4))`\n\n`month = factor(rep(1:2,each=6))`\n\n`day = factor(rep(1:2,each=3))`\n\n`val = round(runif(12),3)`\n\n`d1 = data.frame(loc,month,day,val)`\n\n`d3 = dcast(d1,loc~month+day)`\n\n`melt(d3,variable.name=\"month_day\")`\n\n</div>\\EndKnitrBlock{solutionbox}\n:::\n\n## Advanced data types (Time permitting)\n\nWhile you can usually get away by coding data in not quite the right way - for example, coding dates as numeric values or categorical variables as strings - `R` tries to \"do the right thing\" with your data, and it is more likely to do the right thing the more it knows about how your data are structured.\n\n**Factors instead of strings**\n\nSometimes `R`'s default of assigning characters is not what you want: if your strings are unique identifiers and you want to make it a factor, the default `read.table` will convert this into characters. If all of your non-numeric variables should be treated as factor strings rather than characters, you can just specify `as.is=FALSE`.\n\n**Factors instead of numeric values**\n\nSometimes you have numeric labels for data that are really categorical values - for example if your sites or species have integer codes (often data sets will have redundant information in them, e.g. both a species name and a species code number). It's best to specify appropriate data types, so use colClasses to force R to treat the data as a factor. For example, if we wanted to make tcum a factor instead of a numeric variable:\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-20_734b238e32fde72f1ff4efedfe991511'}\n\n```{.r .cell-code}\ndata2 = read.table(\"seedpred.dat\", header = TRUE, colClasses = c(rep(\"factor\",\n2), rep(\"numeric\", 3)))\nsapply(data2, class)\n```\n:::\n\n\n**n.b.**: by default, `R` sets the order of the factor levels alphabetically. You can find out the levels and their order in a factor `f` with `levels(f)`. If you want your levels ordered in some other way (e.g. site names in order along some transect), you need to specify this explicitly. Most confusingly, `R` will sort strings in alphabetic order too, even if they represent numbers.\n\nThis is OK:\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-21_33ff41720c26ed53af9a8631de881ecf'}\n\n```{.r .cell-code}\nf = factor(1:10)\nlevels(f)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"1\"  \"2\"  \"3\"  \"4\"  \"5\"  \"6\"  \"7\"  \"8\"  \"9\"  \"10\"\n```\n:::\n:::\n\n\nHowever, if we create a factor f through:\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-22_4033614ccda93cea2214aa4a18b36156'}\n\n```{.r .cell-code}\nf = factor(as.character(1:10))\nlevels(f)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"1\"  \"10\" \"2\"  \"3\"  \"4\"  \"5\"  \"6\"  \"7\"  \"8\"  \"9\" \n```\n:::\n:::\n\n\nit will put the `10-th` level as second. You can fix the levels by using the levels argument in `factor()` to tell `R` explicitly what you want it to do, e.g.:\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-23_c5024160bf8e956e937487edd3a46894'}\n\n```{.r .cell-code}\nf = factor(as.character(1:10), levels = c(1:10))\n```\n:::\n\n\nSo the `levels=1:10` argument explicitly states that there are ten levels and that the order of these levels is 1,2,3,4,5,6,7,8,9,10. The levels argument needs a vector of unique numeric values or character strings (`c(1:10)`).\n\nAdditionally, if you create a factor with levels 'north', 'middle' and 'south' they will be sorted by alphabet\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-24_c7fdc8bbe9d669e30b4690b784fb4f85'}\n\n```{.r .cell-code}\nx = c(\"north\", \"middle\", \"south\")\nfactor(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] north  middle south \nLevels: middle north south\n```\n:::\n:::\n\n\nIf you want to sort them geographically instead of alphabetically you again can use the levels argument. Additionally, you can add levels that were not included in the vector itself:\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-25_230ecff4510e2a2283e2b696f0f30191'}\n\n```{.r .cell-code}\nf = factor(x, levels = c(\"far_north\", \"north\", \"middle\", \"south\"))\n```\n:::\n\n\nLikewise, if your data contain a subset of integer values in a range, but you want to make sure the levels of the factor you construct include all of the values in the range, not just the ones in your data. Use levels again:\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-26_c665d3b4c05e420c802902c26ef4d5cd'}\n\n```{.r .cell-code}\nf = factor(c(3, 3, 5, 6, 7, 8, 10), levels = 3:10)\n```\n:::\n\n\nFinally, you may want to get rid of levels that were included in a previous factor but are no longer relevant:\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-27_a26b10de9c71c77e72aef915c0d0d37d'}\n\n```{.r .cell-code}\nf = factor(c(\"a\", \"b\", \"c\", \"d\"))\nf2 = f[1:2]\nlevels(f2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"a\" \"b\" \"c\" \"d\"\n```\n:::\n:::\n\n\nNote that a character vector is returned displaying the different levels in the factor `f`.\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-28_c451789c6c0950210ff651ce95c4ac59'}\n\n```{.r .cell-code}\nf2 = factor(as.character(f2))\nlevels(f2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"a\" \"b\"\n```\n:::\n:::\n\n\n::: {.cell type='exercisebox' latex.options='{2}' hash='index_cache/html/unnamed-chunk-29_d61084f5e18379a9ae8ed1658bfedfb3'}\n\\BeginKnitrBlock{exercisebox}\\iffalse{-123-50-125-}\\fi{}<div class=\"exercisebox\">Illustrate the effects of the levels command by plotting the `factor f=factor(c(3,3,5,6,7,8,10))` as created with and without intermediate levels, i.e. with and without levels c(1:10). For an extra challenge, draw them as two side-by-side subplots. (Use `par(mfrow=c(1,1))` to restore a full plot window.)</div>\\EndKnitrBlock{exercisebox}\n:::\n\n::: {.cell type='solutionbox' latex.options='{block-green}{2}' hash='index_cache/html/unnamed-chunk-30_4506350b1006be964e4b06fbdf0246ed'}\n\\BeginKnitrBlock{solutionbox}\\iffalse{-123-98-108-111-99-107-45-103-114-101-101-110-125-123-50-125-}\\fi{}<div class=\"solutionbox\">`f=factor(c(3,3,5,6,7,8,10))`\n\n`plot(f)`\n\n`f1=factor(c(3,3,5,6,7,8,10),levels=c(3:10))`\n\n`plot(f1)`\n</div>\\EndKnitrBlock{solutionbox}\n:::\n\n**Dates** (time permitting)\n\nDates and times can be tricky in `R`, but you can handle your dates as type `Date` within `R` rather than using Julian days\n\nYou can use `colClasses=\"Date\"` within `read.table()` to read in dates directly from a file, but only if your dates are in four-digit-year/month/day (e.g. 2005/08/16 or 2005-08-16) format; otherwise `R` will either butcher your dates or complain\n\n`Error in fromchar(x) : character string is not in a standard unambiguous format`\n\nIf your dates are in another format in a single column, read them in as character strings (`colClasses=\"character\"` or using `as.is`) and then use `as.Date()`, which uses a very flexible format argument to convert character formats to dates:\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-31_835f264b71b932150918a992baee2534'}\n\n```{.r .cell-code}\nas.Date(c(\"1jan1960\", \"2jan1960\", \"31mar1960\", \"30jul1960\"),\n        format = \"%d%b%Y\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"1960-01-01\" \"1960-01-02\" \"1960-03-31\" \"1960-07-30\"\n```\n:::\n:::\n\n::: {.cell hash='index_cache/html/unnamed-chunk-32_7f86a3dc2f0cb6704cca656b7bad0bd2'}\n\n```{.r .cell-code}\nas.Date(c(\"02/27/92\", \"02/27/92\", \"01/14/92\", \"02/28/92\", \"02/01/92\"), \n        format = \"%m/%d/%y\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"1992-02-27\" \"1992-02-27\" \"1992-01-14\" \"1992-02-28\" \"1992-02-01\"\n```\n:::\n:::\n\n\nThe most useful format codes are `%m` for month number, `%d` for day of month, `%j%` for Julian date (day of year), `%y%` for two-digit year (dangerous for dates before 1970!) and `%Y%` for four-digit year; see `?strftime` for many more details. If you have your dates as separate (`numeric`) day, month, and year columns, you actually have to squash them together into a character format. This can be done with `paste()`, using `sep=\"/\"` to specify that the values should be separated by a slash and then convert them to dates:\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-33_70ac08578577b72dd4dab6b61bdc20fa'}\n\n```{.r .cell-code}\nyear = c(2004,2004,2004,2005)\nmonth = c(10,11,12,1)\nday = c(20,18,28,17)\ndatestr = paste(year,month,day,sep=\"/\")\ndate = as.Date(datestr)\ndate\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"2004-10-20\" \"2004-11-18\" \"2004-12-28\" \"2005-01-17\"\n```\n:::\n:::\n\n\nWhen you want to split a date to month, year and day, you can use 'strsplit':\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-34_50716d954d8f121d9e88d62225bb5cca'}\n\n```{.r .cell-code}\ndate.c = as.character(date)\ndate.char = strsplit(date.c, \"-\" )\n```\n:::\n\n\nWhich you subsequently can turn in to multiple colums through `matrix`:\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-35_eaa8e788cdb3860d00aa49d6dcdb0fd0'}\n\n```{.r .cell-code}\ndat.mat = matrix(unlist(date.char), ncol=3, byrow=TRUE)\n```\n:::\n\n\nAlthough `R` prints the dates in `date` out so they look like a vector of character strings, they are really dates: `class(date)` will give you the answer `\"Date\"`. Note that when using the dat.mat these are characters.\n\n*Pitfall #4 quotation marks in character variables* If you have character strings in your data set with apostrophes or quotation marks embedded in them, you have to get `R` to ignore them. I used a data set recently that contained lines like this: `Western Canyon|valley|Santa Cruz|313120N|1103145WO'Donnell Canyon`\n\nI used\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-36_3f6dc8d196bc8d6cc85e3f37ff4441b5'}\n\n```{.r .cell-code}\ndata3 = read.table(\"datafile\", sep = \"|\", quote = \"\")\n```\n:::\n\n\nto tell `R` that \\| was the separator between fields and that it should ignore all apostrophes/single quotations/double quotations in the data set and just read them as part of a string.\n\n## Accessing data\n\nTo access individual variables within your data set use `mydata$varname` or `mydata[,n]` or `mydata[,\"varname\"]` where `n` is the column number and `varname` is the variable name you want. You can also use `attach(mydata)` to set things up so that you can refer to the variable names alone (e.g. varname rather than mydata\\$varname). However, **beware**: if you then modify a variable, you can end up with two copies of it: one (modified) is a local variable called `varname`, the other (original) is a column in the data frame called `varname`: **it's probably better not to attach a data set, or only until after you've finished cleaning and modifying it**. Furthermore, if you have already created a variable called varname, `R` will find it before it finds the version of `varname` that is part of your data set. Attaching multiple copies of a data set is a good way to get confused: try to remember to `detach(mydata)` when you're done.\n\nHere some examples to get the column with name 'species'\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-37_65eb8dcd50f75e4163617d1db1bf2a39'}\n\n```{.r .cell-code}\ndata[,\"species\"]\ndata[,1]\ndata$species # recommended! You explictly define the dataframe and name of the column \n```\n:::\n\n\nTo access data that are built in to R or included in an R package (which you probably won't need to do often), say\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-38_b2e82050126684f6da4884c2d1969531'}\n\n```{.r .cell-code}\ndata(dataset)\n```\n:::\n\n\n(`data()` by itself will list all available data sets.)\n\n# Plotting\n\nBelow we will show you a diversity of possible graphs that you can produce in R. Graphics are really important to explore the data that you collected and want to analyse. A good data exploration improves the efficiency of your statistical analysis as you will have expectations how relations between variables look like. We show you how to make the graphics using the base plotting functions in `R`, even though specialized packages exist to make particular plots. In addition, we will show you how to make those graphs in `ggplot2` package. The `ggplot2` package is very popular as it can create basically any type of graph without much effort. Note that in ggplot2 the 'grammar' to produce a graph is different from how the other graphs in `R` are build.\n\n## Scatter plot\n\nFrom the previous lab you may remember that the base plot function in R is `plot`. The function `plot` takes a number of arguments but at least you need to specify the `x` and the `y`. If you refer to `x` and `y` by the column name of a `data.frame` you need to specify the name of the data.frame as well through `data`.\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-39_4ce5d04807b7506aef5363ed689d4f46'}\n\n```{.r .cell-code}\nplot(taken ~ available,data=data)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-39-1.png){width=672}\n:::\n:::\n\n\nThe graph above may not be very useful as it does not show how many datapoints are underlying every combination of `seeds taken` and `seeds available`. The function `jitter` adds small noise to a numeric vector which makes that observations that have the same combination of seeds available and taken are plotted at a slightly different location.\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-40_6b0b8d75fcde441ccdffd96d2a693c12'}\n\n```{.r .cell-code}\nplot(jitter(taken)~jitter(available),xlab=\"Seeds available\",\n     ylab=\"Seeds taken\",data=data)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-40-1.png){width=672}\n:::\n:::\n\n\n## Bubble plot\n\nSometimes you have multiple variables in the dataset that you want to explore simultaneously. For example, you want to superimpose information on how often certain combinations of the number seeds available versus the number of seeds taken occur. For this a bubble or jitter plot may be useful. The bubble plot is a normal plot with the size of the points representing the number of observations for a given combination of seeds available and seeds taken.\n\nTo get this information we first need to make a summary table which we can get through:\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-41_d1c48090ae8003f8cece387ec6f2ee4b'}\n\n```{.r .cell-code}\nt1 = table(data$available, data$taken)\n```\n:::\n\n\nThis table needs to changed to a long format in order to be useful for the plotting command. Change the table to a long format with seeds available and seeds taken as columns. Note that we are melting a 2-d array (see ?melt.array)\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-42_ca2f4c34b988e74267a1a558df5aa64f'}\n\n```{.r .cell-code}\nt2 = melt(t1,varnames=c(\"Seeds available\",\"Seeds taken\"),\n          value.name=\"val\")\n```\n:::\n\n\nNow we can make a plot with the size of the bubbles proportional for the number of observations. Since the columnnames have a space in the string we should use the quotes.\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-43_9dbe110c7bd4623c70bc9c745e74e03f'}\n\n```{.r .cell-code}\nplot(`Seeds taken` ~ `Seeds available`,data=t2,cex=val)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-43-1.png){width=672}\n:::\n:::\n\n\nThe argument `cex` controls the size of the points. As you see the size of the bubbles are bit too large, so we need to adjust it. In addition, we need to adjust the scaling of the axis.\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-44_9486699cbf5f95c8745237cfcde6ac74'}\n\n```{.r .cell-code}\nplot(`Seeds taken` ~ `Seeds available`,data=t2,cex=log(val)*2,\n        xlim = c(0.3,5.8),ylim=c(-0.5,5.5))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-44-1.png){width=672}\n:::\n:::\n\n\nIn ggplot this can be done as follows\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-45_0cad2ca78689a38eb8b98a2156eebca2'}\n\n```{.r .cell-code}\nlibrary(ggplot2)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: package 'ggplot2' was built under R version 4.3.1\n```\n:::\n\n```{.r .cell-code}\n    ggplot(data=t2)+\n        geom_point(aes(x = `Seeds available`, y = `Seeds taken`, \n                       size = log(val)/2))+\n      ylab(\"Seeds taken\")+\n      xlab(\"Seeds available\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in sqrt(x): NaNs produced\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Removed 10 rows containing missing values (`geom_point()`).\n```\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-45-1.png){width=672}\n:::\n\n```{.r .cell-code}\n    # or alternatively labs(x=\"Seeds taken\",y=\"Seeds available\")\n```\n:::\n\n\nIn `ggplot2` you need to specify the dataset the variables come from. You do this through `data=...`. Next you specify the type of plot you want. For example, a point plot can be specified through `geom_point`. Within `geom_point`, you need to specify the aesthetics (`aes(x...,y...)`) which determines what is plotted on the axes of the point plot. For example `aes(x=x,y=y)` put column `x` on the x-axis and column `y` on the y-axis.\n\nIf data is specified in the `ggplot` statement, it means that all plotting commands below `ggplot(...)+` use that dataframe as reference. If the size command is put inside the `aes` then size is dependent on some variable, if put outside the `aes` it requires a single value (similarly for e.g. `colour`, `linetype` and `shape`). New commands can be added to the first statement (`ggplot`) by adding a `+` after each line. If a column name contains a space you can refer to it by putting it between backticks: `...`\n\nWe could add the number of observations to the plot (`plot`) using the command `text`. The function `text` needs at least three arguments, the x position and the y position of the text and the text to be printed at this position. `text` allows vectors for each of those arguments. Therefore we can write:\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-46_59f6eb8c9f4e307895a73b7318104e4d'}\n\n```{.r .cell-code}\nplot(`Seeds taken` ~ `Seeds available`,data=t2,cex=log(val)*2,\n        xlim = c(0.3,5.8),ylim=c(-0.5,5.5))\ntext(t2[,1],t2[,2],t2[,3])\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-46-1.png){width=672}\n:::\n:::\n\n\n::: {.cell type='exercisebox' latex.options='{2}' hash='index_cache/html/unnamed-chunk-47_80483e5bcaf5bbddc32ea92ed67c7948'}\n\\BeginKnitrBlock{exercisebox}\\iffalse{-123-50-125-}\\fi{}<div class=\"exercisebox\">Change the size of the printed numbers and remove the zeros from the graph.</div>\\EndKnitrBlock{exercisebox}\n:::\n\n::: {.cell type='solutionbox' latex.options='{block-green}{2}' hash='index_cache/html/unnamed-chunk-48_b440d6095e622b848bf1fbb059e58862'}\n\\BeginKnitrBlock{solutionbox}\\iffalse{-123-98-108-111-99-107-45-103-114-101-101-110-125-123-50-125-}\\fi{}<div class=\"solutionbox\">\nthis removes zeroes and puts it in a new dataframe:\n  \n  `t3 <- t2[t2$val>0,]` \n\nplotting this new dataframe:\n\n  `plot(`Seeds taken` ~ `Seeds available`,data=t3,cex=log(val)*2, \n    xlim = c(0.3,5.8),ylim=c(-0.5,5.5))`\n\n\n\ncex changes the text size:\n  \n  `text(t3[,1],t3[,2],t3[,3],cex=0.8)`\n</div>\\EndKnitrBlock{solutionbox}\n:::\n\n::: {.cell type='exercisebox' latex.options='{2}' hash='index_cache/html/unnamed-chunk-49_2802d391434b9dd6ec256651e068439a'}\n\\BeginKnitrBlock{exercisebox}\\iffalse{-123-50-125-}\\fi{}<div class=\"exercisebox\">Change the color of the points and the symbols. Consult Lab 1 how to do this</div>\\EndKnitrBlock{exercisebox}\n:::\n\n::: {.cell type='solutionbox' latex.options='{block-green}{2}' hash='index_cache/html/unnamed-chunk-50_0a84ffca22ec8e1f5d87049898599701'}\n\\BeginKnitrBlock{solutionbox}\\iffalse{-123-98-108-111-99-107-45-103-114-101-101-110-125-123-50-125-}\\fi{}<div class=\"solutionbox\">\n`plot(`Seeds taken` ~ `Seeds available`,data=t2,cex=log(val)*2,\n        xlim = c(0.3,5.8),ylim=c(-0.5,5.5),col=\"blue\",pch=2)`\n</div>\\EndKnitrBlock{solutionbox}\n:::\n\n## Bar plot (with error bars)\n\nThe command to produce the barplot (Figure 3) was:\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-51_184b4eb1b9bfb5073c5b2149c93a2602'}\n\n```{.r .cell-code}\nbarplot(t(log10(t1 + 1)), beside = TRUE, legend = TRUE, xlab = \"Available\",\n ylab = \"log10(1+# observations)\")\nop = par(xpd = TRUE)\ntext(34.5, 3.05, \"Number taken\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-51-1.png){width=672}\n:::\n\n```{.r .cell-code}\npar(op)\n```\n:::\n\n\nAlternatively through `ggplot`\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-52_df663b20732081102836e0e7af1f3ce5'}\n\n```{.r .cell-code}\nggplot(data=t2)+\n  geom_bar(aes(x=`Seeds available`,y=log10(val+1),\n               fill=as.factor(`Seeds taken`)),\n           stat=\"identity\",position=position_dodge())\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-52-1.png){width=672}\n:::\n:::\n\n\nAgain through `aes` we specify what is on the `x` and `y`. Through `fill` we subdivide the bars by the values in `taken`. `stat=identity` expresses that the values assigned to `y` will be used (compare `stat=\"count\"`). Through specifying `position_dodge()` bars are printed side by side instead of stacked bars (`position_fill()`).\n\nMore impressively, the ggplot package can automatically plot a barplot of a three-way cross-tabulation (one barplot per species): try\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-53_435d218d90278f9270d9ee75821bb898'}\n\n```{.r .cell-code}\nt1.species = table(data$available,data$remaining,data$species)\nt1.species = melt(t1.species,varnames=c(\"Seeds available\",\"Seeds taken\",\n                                        \"species\"),value.name=\"val\")\nggplot(data=t1.species)+\n  geom_bar(aes(x=`Seeds available`,y=log10(val+1),\n               fill=as.factor(`Seeds taken`)),stat=\"identity\",\n           position=position_dodge())+\n  facet_wrap(~species)+\n  coord_flip()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-53-1.png){width=672}\n:::\n:::\n\n\nwith `facet_wrap` a sequence of panels is made a specified by the variable behind the `~`. The `coord_flip` rotates the plot.\n\n::: {.cell type='exercisebox' latex.options='{2}' hash='index_cache/html/unnamed-chunk-54_1d1c65f772ca16543c35acef1cd45b7b'}\n\\BeginKnitrBlock{exercisebox}\\iffalse{-123-50-125-}\\fi{}<div class=\"exercisebox\">Restricting your analysis to only the observations with 5 seeds available, create a barplot showing the distribution of number of seeds taken broken down by species. Choose whether you do this with `ggplot2` or through the base `plot` function.</div>\\EndKnitrBlock{exercisebox}\n:::\n\n::: {.cell type='solutionbox' latex.options='{block-green}{2}' hash='index_cache/html/unnamed-chunk-55_774528b77b35ff0809d9a936645add29'}\n\\BeginKnitrBlock{solutionbox}\\iffalse{-123-98-108-111-99-107-45-103-114-101-101-110-125-123-50-125-}\\fi{}<div class=\"solutionbox\">`t1.species = table(data$available,data$remaining,data$species)`\n\n`t1.species = melt(t1.species,varnames=c(\"Seeds available\",\"Seeds taken\",\"species\"),value.name=\"val\")`\n\n`ggplot(data=t1.species[t1.species$`Seeds available` == 5,])+\n  geom_bar(aes(x=`Seeds taken`,y=val,),stat=\"identity\",\n           position=position_dodge())+\n  facet_wrap(~species)+\n  coord_flip()`\n</div>\\EndKnitrBlock{solutionbox}\n:::\n\nTo add error bars to the barplot, one need to calculate the standard error of the means. We want to plot the standard error on top of the fraction seeds taken\n\nFirst, compute the fraction taken:\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-56_f7cda7ce0e4c08a94fa3102a10c6ecce'}\n\n```{.r .cell-code}\ndata$frac_taken = data$taken/data$available\n```\n:::\n\n\nComputing the mean fraction taken for each number of seeds available, using the `tapply()` function: `tapply()` (\"table apply\", pronounced \"t apply\"), is an extension of the `table()` function; it splits a specified vector into groups according to the factors provided, then applies a function (e.g. `mean()` or `sd()`) to each group. This idea of applying a function to a set of objects is a very general, very powerful idea in data manipulation with `R`; in due course we'll learn about `apply()` (apply a function to rows and columns of matrices), `lapply()` (apply a function to lists), `sapply()` (apply a function to lists and simplify), and `mapply()` (apply a function to multiple lists). For the present, though,\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-57_63e0025ac00514a4d911e8f35bd0adbd'}\n\n```{.r .cell-code}\nmean_frac_by_avail = tapply(data$frac_taken, data$available, mean)\n```\n:::\n\n\ncomputes the mean of `frac_taken` for each group defined by a different value of available. `R` automatically converts available into a factor temporarily for this purpose. If you want to compute the mean by group for more than one variable in a data set, use `aggregate()`. We can also calculate the standard errors, $\\frac{\\sigma}{\\sqrt(n)}$:\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-58_c0e641b54a4d1a3c968c861dce74d29a'}\n\n```{.r .cell-code}\nn_by_avail = table(data$available)\nse_by_avail = tapply(data$frac_taken, data$available, sd)/\n              sqrt(n_by_avail)\n```\n:::\n\n\nFirst we plot a barplot after which we add the error bars. The error bars can be drawn by using the function `arrows` that have an angle between the shaft of the angle and the edge of 90 degrees. To position the error bars at the middle of the bars we need to retrieve those positions from the barplot command. This can be done through assigning a name, e.g. `bara` to the barplot object and using those positions as x coordinates.\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-59_e5a92e59ee212a748c1d5404fd0cd083'}\n\n```{.r .cell-code}\nbara = barplot(mean_frac_by_avail,ylim=c(0,0.09))\n# hack: we draw arrows but with very special \"arrowheads\"\narrows(bara[,1],mean_frac_by_avail-se_by_avail,bara[,1], \n       mean_frac_by_avail+se_by_avail, length=0.05, angle=90, code=3)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-59-1.png){width=672}\n:::\n:::\n\n\nWith `ggplot2` this is possible through the following syntax. Note that there is a convenient function, called `summarySE` in the `Rmisc` package to compute the means and se:\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-60_d788c735eda3eb0da4b5fda0c7c43048'}\n\n```{.r .cell-code}\nlibrary(Rmisc)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: package 'Rmisc' was built under R version 4.3.1\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nLoading required package: lattice\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nLoading required package: plyr\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: package 'plyr' was built under R version 4.3.1\n```\n:::\n\n```{.r .cell-code}\nsum.data = summarySE(data,measurevar= \"frac_taken\",groupvars=c(\"available\"))\nggplot(aes(x=available,y=frac_taken),data=sum.data)+ \n  geom_bar(,stat=\"identity\")+\n  geom_errorbar(aes(ymin=frac_taken-se, ymax=frac_taken+se),\n                stat=\"identity\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-60-1.png){width=672}\n:::\n:::\n\n\nMake sure that the data reference is in the `ggplot()` function so all other functions such as `geom_bar` and `geom_errobar` make use of the same `data.frame`.\n\n## Histogram by species\n\nTo make a histogram we can use the function `hist`:\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-61_89bd7c75f370e1a19ffdcfd002e4dc0d'}\n\n```{.r .cell-code}\nhist(data$frac_taken)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-61-1.png){width=672}\n:::\n:::\n\n\nTo draw a histogram per species, we need to split the data into a list with each element representing a species.\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-62_e357f535c008773eee5a6d8933e0bdcb'}\n\n```{.r .cell-code}\ndata.s = split(data$frac_taken,list(data$species))\n```\n:::\n\n\nNext, we use `sapply` to plot the histograms.\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-63_392e42fd51be8cf4b9d4eaaf815311b4'}\n\n```{.r .cell-code}\npar(mfrow=c(4,2),oma=c(0,0,0,0),mar=c(4,4,0.1,0.1))\nsapply(data.s,hist,main=\"\")\n# or equivalently\nfor (i in 1:8){\n  hist(data.s[[i]],main=\"\")\n}\n```\n:::\n\n\nWith `ggplot2` you can get the frequencies less easily, so will be plot the counts\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-64_07123a25cde0769b3dd164130b99bf5f'}\n\n```{.r .cell-code}\nggplot(data=data)+\ngeom_bar(aes(x=frac_taken),stat=\"count\")+\n  facet_wrap(~ species)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-64-1.png){width=672}\n:::\n:::\n\n::: {.cell hash='index_cache/html/unnamed-chunk-65_e1239159e8a4ad9ee8ed8c693e523316'}\n\n```{.r .cell-code}\nggplot(data=data,aes(x=frac_taken))+\n  geom_histogram(aes(y = ..density..))+\n  facet_wrap(~species)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: The dot-dot notation (`..density..`) was deprecated in ggplot2 3.4.0.\nℹ Please use `after_stat(density)` instead.\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n```\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-65-1.png){width=672}\n:::\n:::\n\n\nI'm going to clear the workspace with `rm(list=ls())`. `ls()` lists all the objects in the workspace with `ls()` and then uses `rm()` to remove them. It is recommend to have this code at the top of every script, so every time you start working on the script you are sure the memory is cleared. You can also clear workspace from the menu in Rstudio (the little brush in the topright panel) and read in the measles data, which are space separated and have a header:\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-66_56427b48654ae7ad970031b1f4c009b5'}\n\n```{.r .cell-code}\nrm(list = ls())\ndata = read.table(\"ewcitmeas.dat\", header = TRUE, na.strings = \"*\")\n```\n:::\n\n\n`year`, `mon`, and `day` were read in as integers: I'll create a date variable as described above. For convenience, I'm also defining a variable with the city names.\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-67_38f9e31e8387240385fd3187aaf4f3e4'}\n\n```{.r .cell-code}\ndate = as.Date(paste(data$year + 1900, data$mon, data$day, sep = \"/\"))\ncity_names = colnames(data)[4:10]\n```\n:::\n\n\nLater on it will be useful to have the data in long format. It's easiest to do use `melt` for this purpose. Note that only need to select the appropriate columns to melt (i.e. 4-11).\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-68_6a0dd27a59771d220adadca3cc21cfe5'}\n\n```{.r .cell-code}\nlibrary(reshape2)\ndata= cbind(data,date)\ndata_long = melt(data[,4:11],id.vars=8,variable.name = \"city\",\n                 value.name=\"incidence\")\n```\n:::\n\n\n## Multiple-line plots\n\nWe can make a plot with multiple lines as follows. We first setup the plotting region using `plot` followed by the function `lines` to add lines to the existing plot. Note that in the plotting command `type=\"l\"` is used to specify that lines are drawn instead of point (`type=\"p\"`, the default). A legend can be added by adding the function `legend`\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-69_cdb386bce9c9b7092397686eea29f704'}\n\n```{.r .cell-code}\ndata_long.s = split(data_long,data_long$city)\nplot(incidence ~ date,col=1,type=\"l\",\n     data=data_long[data_long$city == \"London\",])\n\nunique.city = unique(data_long$city)\nfor (i in 2:length(unique.city)){\n  lines(incidence ~ date,type=\"l\",\n        data=data_long[data_long$city == unique.city[i],],col=i)\n}\nlegend(\"topright\",legend=unique.city,col=1:8,lty=1)\n```\n:::\n\n\nWith ggplot2 we specify\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-70_a45eb9a7812c7b22e5195189241c56b5'}\n\n```{.r .cell-code}\nggplot() +\n  geom_line(aes(x=date,y=incidence, colour=city),data=data_long)\n```\n:::\n\n\n## Histogram and density plots\n\nI'll start by just collapsing all the incidence data into a single, logged, non-NA vector (in this case I have to use `c(as.matrix(x))` to collapse the data and remove all of the data frame information):\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-71_438345353612cc8ed6bd4356ed076cb7'}\n\n```{.r .cell-code}\nallvals = na.omit(c(as.matrix(data[, 4:10])))\nlogvals = log10(1 + allvals)\n```\n:::\n\n\nThe histogram (`hist()` command is fairly easy: the only tricks are to leave room for the other lines that will go on the plot by setting the y limits with ylim, and to specify that we want the data plotted as relative frequencies, not numbers of counts (`freq=FALSE` or `prob=TRUE`). This option tells `R` to divide by total number of counts and then by the bin width, so that the area covered by all the bars adds up to 1. This scaling makes the vertical scale of the histogram compatible with a density plot, or among different histograms with different number of counts or bin widths.\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-72_6dfe469ec049c35c92bf425e56457dd5'}\n\n```{.r .cell-code}\nhist(logvals, col = \"gray\", main = \"\", xlab = \"Log weekly incidence\",\n ylab = \"Density\", freq = FALSE, ylim = c(0, 0.6))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-72-1.png){width=672}\n:::\n:::\n\n\nAdding lines for the density is straightforward, since R knows what to do with a density object - in general, the lines command just adds lines to a plot.\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-73_b5605d8722ef2ad39421ae6c4ed9462e'}\n\n```{.r .cell-code}\nlines(density(logvals), lwd = 2)\nlines(density(logvals, adjust = 0.5), lwd = 2, lty = 2)\n```\n:::\n\n\nWith ggplot2 we specify:\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-74_37ef9fb960d3ad44571981e40836c66c'}\n\n```{.r .cell-code}\nggplot()+\n  geom_histogram(aes(x=logvals,y=..density..))+\n  geom_density(aes(x=logvals,y=..density..))\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n```\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-74-1.png){width=672}\n:::\n:::\n\n\n## Scaling data\n\nScaling the incidence in each city by the population size, or by the mean or maximum incidence in that city, begins to get us into some non-trivial data manipulation. This process may actually be easier in the wide format. Several useful commands: \\* `rowMeans()`, `rowSums()`, `colMeans()`, and `colSums()` will compute the means or sums of columns efficiently. In this case we would do something like `colMeans(data[,4:10]`) to get the mean incidence for each city.\n\n-   `apply()` is the more general command for running some command on each of a set of rows or columns. When you look at the help for apply() you'll see an argument called MARGIN, which specifies whether you want to operate on rows (1) or columns (2). For example, `apply(data[,4:10],1,mean)` is the equivalent of `rowMeans(data[,4:10])`, but we can also easily say (e.g.) `apply(data[,4:10],1,max)` to get the maxima instead. Later, when you've gotten practice defining your own functions, you can apply any function - not just R's built-in functions.\n\n-   `scale()` is a function for subtracting and dividing specified amounts out of the columns of a matrix. It is fairly flexible: `scale(x,center=TRUE,scale=TRUE)` will center by subtracting the means and then scale by dividing by the standard errors of the columns. Fairly obviously, setting either to FALSE will turn off that part of the operation. You can also specify a vector for either center or scale, in which case scale() will subtract or divide the columns by those vectors instead.\n\n::: {.cell type='exercisebox' latex.options='{2}' hash='index_cache/html/unnamed-chunk-75_0574d2f41a8a4d007fa4a78c4bae6a42'}\n\\BeginKnitrBlock{exercisebox}\\iffalse{-123-50-125-}\\fi{}<div class=\"exercisebox\">Figure out how to use apply() and scale() to scale all columns so they have a minimum of 0 and a maximum of 1 (hint: subtract the minimum and divide by (max-min)). </div>\\EndKnitrBlock{exercisebox}\n:::\n\n::: {.cell type='solutionbox' latex.options='{block-green}{2}' hash='index_cache/html/unnamed-chunk-76_daa56b4b42274a9d810bb9b5fc404dca'}\n\\BeginKnitrBlock{solutionbox}\\iffalse{-123-98-108-111-99-107-45-103-114-101-101-110-125-123-50-125-}\\fi{}<div class=\"solutionbox\">\nThis solution can be made more elegant once we have learned to program our own functions\n\n`incidence = data[,4:10]`\n\n`incidence.min= apply(incidence,2,min,na.rm=T)`\n\n`incidence.max= apply(incidence,2,max,na.rm=T)`\n\n`range = incidence.max-incidence.min`\n\n`data.scaled = scale(incidence, center=incidence.min,scale=range)`\n\n`summary(data.scaled)`\n\n</div>\\EndKnitrBlock{solutionbox}\n:::\n\n## Box-and-whisker and violin plots\n\nBy this time, box-and-whisker and violin plots will (I hope) seem easy. Since the labels get a little crowded (`R` is not really sophisticated about dealing with axis labels-crowded labels), I'll use the `substr()` (substring) command to abbreviate each city's name to its first three letters.\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-77_d98baa48fe8f6219aa5bdfbb0e078f37'}\n\n```{.r .cell-code}\ncity_abbr = substr(city_names, 1, 3)\n```\n:::\n\n\nThe `boxplot()` command uses a formula - the variable before the \\~ is the data and the variable after it is the factor to use to split the data up.\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-78_7c6ef0c1ef7b4e7324ab33878ef3adb4'}\n\n```{.r .cell-code}\nboxplot(log10(1 + incidence) ~ city, data = data_long, ylab = \"Log(incidence+1)\",\n names = city_abbr)\n```\n:::\n\n\nOr through ggplot\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-79_0ba51c1e7d1a61524f5c2cd4f25be9f1'}\n\n```{.r .cell-code}\nggplot(data=data_long)+\n  geom_boxplot((aes(x=city,y=log10(incidence+1))))\n```\n:::\n\n\nIf I want to make a violin plot, you can specify:\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-80_b1b78d399df74cb28ce2c6a33a2fc78b'}\n\n```{.r .cell-code}\nggplot(data=data_long)+\n  geom_violin((aes(x=city,y=log10(incidence+1))))\n```\n:::\n\n\n## Pair plot\n\nFirst let's make sure the earthquake data are accessible:\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-81_f6fe70333dcbf8107d7777dbeed81f79'}\n\n```{.r .cell-code}\ndata(quakes)\n```\n:::\n\n\nLuckily, most of the plots I drew in this section are fairly automatic. To draw a scatterplot matrix, just use `pairs()` (base):\n\n\n::: {.cell hash='index_cache/html/unnamed-chunk-82_7e8f90bc900b7c890f13fc5f17a097c7'}\n\n```{.r .cell-code}\npairs(quakes, pch = \".\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-82-1.png){width=672}\n:::\n:::\n\n\n(`pch=\".\"` marks the data with a single-pixel point, which is handy if you are fortunate enough to have a really big data set).\n\n::: {.cell type='exercisebox' latex.options='{2}' hash='index_cache/html/unnamed-chunk-83_93266e01085efa786b64781aae96329f'}\n\\BeginKnitrBlock{exercisebox}\\iffalse{-123-50-125-}\\fi{}<div class=\"exercisebox\">Generate three new plots based on one of the data sets in this lab, or on your own data.</div>\\EndKnitrBlock{exercisebox}\n:::\n\n::: {.cell type='solutionbox' latex.options='{block-green}{2}' hash='index_cache/html/unnamed-chunk-84_33631f733ecf6a869fa5e4680a348e59'}\n\\BeginKnitrBlock{solutionbox}\\iffalse{-123-98-108-111-99-107-45-103-114-101-101-110-125-123-50-125-}\\fi{}<div class=\"solutionbox\">\nThis is up to your creativity\n</div>\\EndKnitrBlock{solutionbox}\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}