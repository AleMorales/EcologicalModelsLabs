{
  "hash": "de2d59d1df9ab54427faa45804bf11c3",
  "result": {
    "markdown": "---\ntitle: \"An introduction to `R` for ecological modeling (lab 1)\"\nauthor:\n- Stephen Ellner, modified by Ben Bolker & Bob Douma.\n- Adapted to R Markdown by Alejandro Morales.\ndate: \"October 25, 2023\"\ncache: true\nvisual: false\nparams:\n  solution: false\n# output:\n#   bookdown::pdf_book:\n#     includes:\n#       in_header: preamble1.tex\n#   word_document: default\n#   pdf_document: default\n#   html_document:\n#     fig_caption: yes\n#     fig_height: 4.5\n#     fig_width: 5\n#     number_sections: yes\n# geometry: margin=3cm\n# fontsize: 11pt\n---\n\n\n\n\n# Learning outcomes\nThe aim of this tutorial is to learn the basics of `R`. After completing the tutorial you will be able to:\n\n1. Install `R` and associated packages and Rstudio\n\n2. Do interactive calculations in the `R` console\n\n3. Consult the built-in help in `R`\n\n4. Create, modify and run `R` scripts\n\n5. Setup a typical workflow in `R` (loading libraries, reading data, doing statistics and saving results)\n\n6. Work with the most common data types in `R` (vectors, matrices, lists and data frames)\n\n\n::: {.cell hash='no_solution_cache/html/unnamed-chunk-1_52de1ed09c1754dca164ad6928f7f47c'}\n\n:::\n\n\n\n# How to use this tutorial\n\n* This tutorial contains many sample calculations. It is important to do these yourself---**type them in at your keyboard and see what happens on your screen**---to get the feel of working in `R`. \n\n* **Exercises** in the middle of a section should be done immediately, and make sure you have them rightly solved before moving on. Some other, more challenging, exercises appear at the end of some sections, and these can be left until later.  \n\n# What is `R`?\n\n`R` is an object-oriented scripting language that  \n\n* can be used for numerical simulation of deterministic and stochastic dynamic models.\n\n* has an extensive set of functions for classical and modern statistical data analysis and modeling.\n \n* has graphics functions for visualizing data and model output\n\n* a user interface with a few basic menus and extensive help facilities\n\n`R` is an open source project, available for free download via the Web. Originally a research project in statistical computing it is now managed by a development team that includes a number of well-regarded statisticians. It is widely used by statistical researchers and a growing number of theoretical ecologists and ecological modelers as a platform for making new methods available to users. \n\n# Installing `R` on your computer: basics\n\nIf `R` is already installed on your computer, you can skip this section.\n\nThe main source for `R` is the CRAN home page `http://cran.r-project.org`. \nYou can get the source code, but most users will prefer a precompiled \nversion. To get one of these from CRAN:\n\n* go to `http://cran.r-project.org/mirrors.html` and find\na mirror site that is geographically somewhat near you.\n\n* Find the appropriate page for your operating system --- when you get to the\ndownload section, go to `base` rather than `contrib`. Download the binary file (e.g. `base/R-x.y.z-win32.exe` for Windows, `R-x.y.z.dmg` for MacOS, where `x.y.z` is the version number). The binary files are large (30--60 megabytes) --- you will need to find a fast internet connection.\n\n* Read and follow the instructions (which are pretty much \"click on the icon\").\n\n\n# Installing and using Rstudio  \nNowadays programs are available that integrate `R` in a sophisticated way by combining a console, a *syntax highlighting* editor (giving colors to `R` commands and allowing you to identify missing parentheses, quotation marks etc.), tools for plotting, debugging, workspace management and connections to versioning systems into one program. Rstudio is currently the most advanced wrapper around R and is highly recommended if `R` is the core of your work. Rstudio can be found and downloaded at https://www.rstudio.com. \n\nIf a new `R` version is launched after you installed Rstudio, you can change the `R` version that is used in Rstudio by clicking on `Tools` and `Global Options`, choose `R general` and select the location of the most recent `R` version.\n\nRstudio usually displays four panels. The default setting is a script editor at the top-left of the screen, the console at the bottom-left, the global environment (which shows what is stored in the memory) at the top-right, and a plotting region at bottom-right. As you see some panel have multiple tabs that include other useful features such as the help (bottom-right), the (available and loaded) packages (bottom-right) etc.\n\n# The `R` package system\nThe standard distributions of `R` include several *packages*, user-contributed suites of add-on functions. This lab uses some packages that are not part of the standard distribution. In general, you can install additional packages \nfrom within `R` using the `Packages` menu, or the `install.packages` command.\n\nYou may be able to install new packages from a menu within `R`. Type and it will installe the package `ggplot2` that you will use in the next tutorial.\n\n\n::: {.cell hash='no_solution_cache/html/df-drop-2_63c9584264b5c87db0789a20abf524c9'}\n\n```{.r .bad-code .cell-code}\ninstall.packages(\"ggplot2\")\n```\n:::\n\n\n(for example --- this installs the `ggplot2` package). You can install more than one package at a time:\n\n\n::: {.cell hash='no_solution_cache/html/unnamed-chunk-2_5ddc18d6f21e1f14b79ea593037a9878'}\n\n```{.r .cell-code}\ninstall.packages(c(\"ggplot2\",\"nlme\"))\n```\n:::\n\n\n(`c` stands for \"combine\", and is the command for combining multiple things into a single object.) \n\nSome of the important functions and packages (collections of functions) for statistical modeling and data analysis are summarized in Table 2. Venables and Ripley (2002) give a good practical (although somewhat advanced) overview, and you can find a list of available packages and their contents at CRAN, the main `R` website (http://www.cran.r-project.org --- select a mirror site near you and click on `Package sources`). For the most part, we will not be concerned here with this side of `R`.\n\n\n::: {.cell hash='no_solution_cache/html/unnamed-chunk-3_4b3e7e0469d15dbc57ad2ecc5c985c91'}\n::: {.cell-output-display}\n\\begin{table}\n\n\\caption{\\label{tab:unnamed-chunk-3}A few of the functions and packages in `R` for statistical modeling and data analysis. There are \\emph{many} more, but you will have to learn about them somewhere else.}\n\\centering\n\\resizebox{\\linewidth}{!}{\n\\begin{tabular}[t]{ll}\n\\toprule\nFunction & Definition and packages\\\\\n\\midrule\n\\texttt{aov}, \\texttt{anova} & Analysis of variance or deviance\\\\\n\\texttt{lm} & Linear models (regression, ANOVA, ANCOVA)\\\\\n\\texttt{glm} & Generalized linear models (e.g. logistic, Poisson regression)\\\\\n\\texttt{gam} & Generalized additive models (in package \\texttt{mgcv})\\\\\n\\texttt{nls} & Fit nonlinear models by least-squares\\\\\n\\addlinespace\n\\texttt{lme}, \\texttt{nlme},\\texttt{lmer}, \\texttt{glmer} & Linear, generalized linear, and nonlinear mixed-effects models\\\\\n & (repeated measures, block effects, spatial models) in packages\\\\\n & \\texttt{nlme} and \\texttt{lme4}\\\\\n\\texttt{boot} & Package: bootstrapping functions\\\\\n\\texttt{splines} & Package: nonparametric regression (more in packages \\texttt{fields},\\\\\n\\addlinespace\n & \\texttt{KernSmooth}, \\texttt{logspline}, \\texttt{sm} and others)\\\\\n\\texttt{princomp}, \\texttt{manova}, \\texttt{lda}, \\texttt{cancor} & Multivariate analysis (some in package \\texttt{MASS}; also see packages\\\\\n & \\texttt{vegan}, \\texttt{ade4})\\\\\n\\texttt{survival} & Package: survival analysis\\\\\n\\texttt{tree}, \\texttt{rpart} & Packages: tree-based regression\\\\\n\\bottomrule\n\\end{tabular}}\n\\end{table}\n:::\n:::\n\n\n\n# Interactive calculations in the console\nThe console is where you enter commands for `R` to execute *interactively*, meaning that the command is executed and the result is displayed as soon as you hit the `Enter` key (bottom-left panel in Rstudio). For example, at the command prompt `>`, type in `2+2` and hit `Enter`; you will see \n\n\n::: {.cell hash='no_solution_cache/html/unnamed-chunk-4_e12a7a670355379410d1faf7be62057f'}\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4\n```\n:::\n:::\n\nTo do anything complicated, you have to store the results from calculations by *assigning* them to variables, using `=` or `<-`. For example:\n\n\n::: {.cell hash='no_solution_cache/html/unnamed-chunk-5_7f310682218eb6bc677e79ea51109831'}\n\n```{.r .cell-code}\na=2+2\n```\n:::\n\n\n`R` automatically creates the variable `a` and stores the result (4) in it, but it doesn't print anything. This may seem strange, but you'll often be creating and manipulating huge sets of data that would fill many screens, so the default is to skip printing the results. To ask `R` to print the value, just type the variable name by itself at the command prompt:\n\n::: {.cell hash='no_solution_cache/html/unnamed-chunk-6_9dd4de2335186b9706579d2262b45bf3'}\n\n```{.r .cell-code}\na\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4\n```\n:::\n:::\n\n\n(the `[1]` at the beginning of the line is just `R` printing an index of element numbers; if you print a result that displays on multiple lines, `R` will put an index at the beginning of each line. `print(a)` also works to print the value of a variable.) By default, a variable created this way is a *vector*,  and it is *numeric* because we gave `R` a number rather than some other type of data (e.g. a character string like `\"pxqr\"`). In this case `a` is a numeric vector of length 1, which acts just like a number. \n\nYou could also type `a=2+2; a`, using a semicolon to put two or more commands on a single line. Conversely, you can break lines *anywhere that `R` can tell you haven't finished your command* and `R` will give you a \"continuation\" prompt (`+`) to let you know that it doesn't think you're finished yet: try typing \n\n::: {.cell hash='no_solution_cache/html/unnamed-chunk-7_8cc0fdc39bbf231d481e551170f5bcce'}\n\n```{.r .cell-code}\na=3*(4+ [Enter]\n5)\n```\n:::\n\n\nto see what happens. You will sometimes see the continuation prompt when you don't expect it, e.g. if you forget to close parentheses.If you get stuck continuing a command you don't want---e.g. you opened the wrong parentheses---just hit the `Escape` key or the stop icon in the menu bar to get out.\n\nVariable names in `R` must begin with a letter, followed by letters or numbers. You can break up long names with a period, as in `very.long.variable.number.3`, or an underscore (`_`), but you can't use blank spaces in variable names (or at least it's not worth the trouble).\nVariable names in `R` are case sensitive, so `Abc` and `abc` \nare different variables. Make variable names long enough to remember, short\nenough to type.`N.per.ha` or `pop.density` are better than `x`\nand `y` (too short) or `available.nitrogen.per.hectare` (too long).\nAvoid `c`, `l`, `q`, `t`, `C`, `D`, `F`, `I`, and `T`, which are either built-in `R` functions or hard to tell apart.\n\n`R` does calculations with variables as if they were numbers. It uses \n`+`, `-`, `*`, `/`, and `^` for addition, subtraction, multiplication, division and  exponentiation, respectively. For example:\n\n\n::: {.cell hash='no_solution_cache/html/unnamed-chunk-8_439eeb26ddbb016c2bee73fc5d56e42e'}\n\n```{.r .cell-code}\nx=5\ny=2\nz1=x*y ## no output\nz2=x/y ## no output\nz3=x^y ## no output\nz2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2.5\n```\n:::\n\n```{.r .cell-code}\nz3\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 25\n```\n:::\n:::\n\n\nEven though `R` did not display the values of `x` and `y`, it \"remembers\" that it assigned values to them. Type `x; y` to display the values. \n\nYou can retrieve and edit previous commands. The up-arrow ($\\uparrow$) in the console recalls previous commands to the prompt. They also can be found in the top-right tab `History`. For example, you can bring back the second-to-last command and edit it into \n\n::: {.cell hash='no_solution_cache/html/unnamed-chunk-9_d7fcf0f1f557a98fad5c8eeae4533bde'}\n\n```{.r .cell-code}\nz3=2*x^y\n```\n:::\n\n\nYou can combine several operations in one calculation:\n\n::: {.cell hash='no_solution_cache/html/unnamed-chunk-10_b6149b7a7532f310a89caf777976f391'}\n\n```{.r .cell-code}\nA=3\nC=(A+2*sqrt(A))/(A+5*sqrt(A))\nC\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.5543706\n```\n:::\n:::\n\n\nParentheses specify the order of operations. \nThe command\n\n::: {.cell hash='no_solution_cache/html/unnamed-chunk-11_38f58b7dee974cd9c537bd0c139a12c4'}\n\n```{.r .cell-code}\nC=A+2*sqrt(A)/A+5*sqrt(A)\n```\n:::\n\nis not the same as the one above; rather, it is equivalent to `C=A + 2*(sqrt(A)/A) + 5*sqrt(A)`.\n\nThe default order of operations is: (1) parentheses; (2) exponentiation, or powers, (3) multiplication and division, (4) addition and subtraction. \n\nb = 12-4/2^3 gives 12 - 4/8 = 12 - 0.5 = 11.5\n\nb = (12-4)/2^3 gives 8/8 = 1\n\nb = -1^2 gives -(1^2) = -1\n\nb = (-1)^2 gives 1\n\nIn complicated expressions you might start off by *using parentheses to specify explicitly what you want*, such as b = 12 - (4/(2^3)) \nor at least b = 12 - 4/(2^3); a few extra sets of parentheses never hurt, although when you get confused it's better to think through the order of operations rather than flailing around adding parentheses at random. `R` also has many *built-in mathematical functions* that operate on variables\n(Table 1 shows a few). \n\n\n::: {.cell hash='no_solution_cache/html/unnamed-chunk-12_0ca6067fdb770a75e8679fa388347396'}\n::: {.cell-output-display}\n\\begin{table}\n\n\\caption{\\label{tab:unnamed-chunk-12}Some of the built-in mathematical functions in R. You can get a more complete list from the Help system: \\texttt{?Arithmetic} for simple, \\texttt{?log} for logarithmic, \\texttt{?sin} for trigonometric, and \\texttt{?Special} for special functions.}\n\\centering\n\\begin{tabular}[t]{ll}\n\\toprule\nFunction & Definition\\\\\n\\midrule\n\\texttt{abs} & absolute value\\\\\n\\texttt{cos, sin, tan} & cosine, sine, tangent of angle $x$ in radians\\\\\n\\texttt{exp} & exponential function, $e^x$\\\\\n\\texttt{log} & natural (base-$e$) logarithm\\\\\n\\texttt{log10} & common (base-10) logarithm\\\\\n\\addlinespace\n\\texttt{sqrt} & square root\\\\\n\\bottomrule\n\\end{tabular}\n\\end{table}\n:::\n:::\n\n\n::: {.cell type='exercisebox' latex.options='{1}' hash='no_solution_cache/html/unnamed-chunk-13_b8e0cbc741450c1784566463894fb0b7'}\n\\BeginKnitrBlock{exercisebox}\\iffalse{-123-49-125-}\\fi{}<div class=\"exercisebox\">Using editing shortcuts wherever you can, have `R` compute the values of:\n  \n\n1. $\\frac{2^7}{2^7 - 1}$ and compare it with $({1 - \\frac{1}{2^7}})^{-1}$ \n \n2.\n  * $1+0.2$\n  * $1+0.2+0.2^2/2 + \\cos(2.3)$\n  * $\\log(1)$\n  * $\\exp(0.2)$ \n3. The standard normal probability density, $\\frac{1}{\\sqrt(2\\pi)}\\exp(-x^2/2)$, for values of $x=1$ and $x=2$ (`R` knows $\\pi$ as `pi`). You can check your answers against the built-in function for the normal distribution; `dnorm(1)`  and `dnorm(2)` should give you the values for the standard normal for $x=1$ and $x=2$.\n</div>\\EndKnitrBlock{exercisebox}\n:::\n\n::: {.cell type='solutionbox' latex.options='{1}' hash='no_solution_cache/html/unnamed-chunk-14_c5690396d066cffa91c346a07e9c9142'}\n\n:::\n\n# The help system\nR has a help system, although it is generally better for providing detail or reminding you how to do things than for basic ``how do I ...?'' questions.\n\n* You can get help on any R function by entering\n  ```\n  ?foo\n  ```\n  Where `foo` is the name of the function you are interested in (e.g., try `?sin`).\n\n* `??topic` or `help.search(\"topic\")`\n (with quotes) will list information related to `topic` available in the base system or in any extra installed packages: then use `?topic` to see the information, perhaps using `library(pkg)` to load the appropriate package first. `help.search` uses \"fuzzy matching\" --- for example,\n`help.search(\"log\")` finds 528 entries (on my particular system) including lots of functions with \"plot\", which includes the letters \"lot\", which\nare *almost* like \"log\". If you can't stand it, you can turn this behavior off by specifying the incantation `help.search(\"log\",agrep=FALSE)` (81 results which still include matches for \"logistic\", \"myelogenous\", and \"phylogeny\" ...)\n\n\n* On-line help resources - just google it. \nIn our experience, the help provided by `R` requires some experience in the `R` language to be able to understand it. Therefore, a general, but practical advice is to google your problem. In 99.9% of the cases someone else had a similar question in the past which were solved by the `R` community. Start you search string with \"R-help\" helps to filter relevant webpages. Place were you likely will find answers are https://stackoverflow.com or https://stat.ethz.ch.\n\n\n\n\n\n# Using scripts and data files\nModeling and complicated data analysis are often much easier if you use *scripts*, which are a series of commands stored in a text file. Scripting has a number of advantages and should be standard practice when doing statstics for reasons of transparency (you can see what you have done), repeatability (tomorrow you will get the same result as today) and transferability (a colleague can easily check what you have done and redo your analysis). Even for relatively simple tasks, script files are useful for building up a calculation step-by-step, making sure that each part works before adding on to it. We recommend you making a habit typing all commands in a script editor before sending it the console, otherwise important parts of your analysis may get lost because you did not store them.\n\nRstudio has an advanced script editor that recognizes `R` syntax by giving different colors to different `R` commands and by automatic completion of parentheses. You can also use Windows Notepad or Wordpad but you **should not** use MS Word.\n\nMost programs for working with models or analyzing data follow a simple pattern of program parts:\n\n1. \"Setup\" statements. For example, load some packages, or run another script file that\ncreates some functions (more on functions later).\n\n2. Input some data from a file or the keyboard. For example, read in data from a text file.\n\n3. Carry out the calculations that you want. For example, fit several statistical models to the data and compare them.\n\n4. Print the results, graph them, or save them to a file. For example, graph the results, and save the graph to disk for including in your term project.\n\nTo tell `R` where data and script files are located, you can do any one of the following:\n\n* spell out the *path*, or file location, explicitly. (Use\na single forward slash to separate folders (e.g. `\"c:/My Documents/R/script.R\"`): this works on all platforms.)\n\n* change your working directory to wherever the file(s) are located using the `setwd` (**set** **w**orking **d**irectory) function, e.g. `setwd(\"c:/temp\")` or through clicking on 'Session' and 'set working directory'. Changing your working directory is more efficient in the long run, if you save all the script and data files for a particular project in the same directory and switch to that directory when you start work.\n\n# Typical workflow in `R`: an example using linear regression\nTo get a feel for a typical workflow in R we'll fit a straight-line model (linear regression) to data.\n\nStart a blank `R` script (File -> New File -> R script) and save it on a convenient location.\n\nBelow are some data on the maximum growth rate $r_{max}$ of laboratory populations  of the green alga *Chlorella vulgaris* as a function of light intensity ($\\mu$E per m$^2$ per second). These experiments were run during the system-design phase of the study reported by Fussman et al. (2000).\n\nLight: 20, 20, 20, 20, 21, 24, 44, 60, 90, 94, 101\n\n$r_{max}$: 1.73, 1.65, 2.02, 1.89, 2.61, 1.36, 2.37, 2.08, 2.69, 2.32, 3.67\n\nTo analyze these data in R, first enter them as numerical *vectors* in your script and send them to the console:\n\n\n::: {.cell hash='no_solution_cache/html/unnamed-chunk-15_e9f0e56646fa475017ca2eac154cc912'}\n\n```{.r .cell-code}\nLight=c(20,20,20,20,21,24,44,60,90,94,101)\nrmax=c(1.73,1.65,2.02,1.89,2.61,1.36,2.37,2.08,2.69,2.32,3.67)\n```\n:::\n\n\nThe function `c` *combines* the individual numbers into a vector. Try recalling (with $\\uparrow$) and modifying the above command to\n```\nLight=20,20,20,20,21,24,44,60,90,94,101\n```\nand see the error message you get: in order to create a vector of specified numbers, you **must** use the `c` function. Don't be afraid of error messages: the answer to \"what would happen if I ...?\" is usually \"try it and see!\"\n\nTo see a histogram of the growth rates enter `hist(rmax)`, which opens a graphics window and displays the histogram. There are *many* other built-in statistics functions: for example `mean(rmax)` computes you the mean, and `sd(rmax)` and `var(rmax)` compute the standard deviation and variance, respectively. Play around with these functions, and any others you can think of.\n\nTo see how light intensity affects algal rate of increase, type\n\n::: {.cell hash='no_solution_cache/html/unnamed-chunk-16_13c19e324e9b99f2203811c7ab10c2f8'}\n\n```{.r .cell-code}\nplot(rmax ~ Light)\n```\n:::\n\n\nin the script (and send it the console) to plot `rmax` ($y$) against `Light` ($x$). The `~` sign implies \"as a function of\". Alternatively, type `plot(Light,rmax)`. A linear regression would seem like a reasonable model for these data. **Don't close this plot window**: we'll soon be adding to it.\n\n\n::: {.cell fig='true' height='2' hash='no_solution_cache/html/unnamed-chunk-17_784d7dea42a57e40ecf336708ce16278'}\n::: {.cell-output-display}\n![Some of R's graphics parameters. Color specification, `col`, also applies in many other contexts: colors are set to a rainbow scale here. See `?par` for (many more) details on graphics parameters, and one or more of `?rgb`, `?palette`, or `apropos(\"color\")` for more on colors.](no_solution_files/figure-html/unnamed-chunk-17-1.png){width=576}\n:::\n:::\n\n\n`R`'s default plotting character is an open circle. Open symbols are generally better than closed symbols for plotting because it is easier to see where they overlap, but you could include `pch=16` in the `plot` command if you wanted closed circles instead. Figure 1 shows several more ways to adjust the appearance of lines and points in `R`.\n\nTo perform linear regression we create a linear model using the `lm` (**l**inear **m**odel) function:\n\n::: {.cell hash='no_solution_cache/html/unnamed-chunk-18_c5693dc3f7b735e08888443fe14079c6'}\n\n```{.r .cell-code}\nfit = lm(rmax~Light)\n```\n:::\n\n(Note that linear model is read as \"model $r_{max}$ as a function of light\".)\n\nThe `lm` command produces no output at all, but it creates `fit` as an **object**, i.e. a data structure consisting of multiple parts, holding the results of a regression analysis with `rmax` being modeled as a\nfunction of `Light`. Unlike most statistics packages, R rarely produces automatic  summary output from an analysis.  Statistical analyses in R are done by creating a  model, and then giving additional commands to extract desired information  about the model or display results graphically.\n\nTo get a summary of the results, enter  the command `summary(fit)`. `R` sets up model objects (more on this later)  so that the function `summary` \"knows\" that `fit` was created by `lm`, and produces an appropriate summary of results for an `lm` object:\n\n\n::: {.cell hash='no_solution_cache/html/unnamed-chunk-19_04d0536b8afe1b4b8ae2c798f1979e71'}\n\n```{.r .cell-code}\nsummary(fit)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nCall:\nlm(formula = rmax ~ Light)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-0.5478 -0.2607 -0.1166  0.1783  0.7431 \n\nCoefficients:\n            Estimate Std. Error t value Pr(>|t|)    \n(Intercept) 1.580952   0.244519   6.466 0.000116 ***\nLight       0.013618   0.004317   3.154 0.011654 *  \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 0.4583 on 9 degrees of freedom\nMultiple R-squared:  0.5251,\tAdjusted R-squared:  0.4723 \nF-statistic: 9.951 on 1 and 9 DF,  p-value: 0.01165\n```\n:::\n:::\n\n\n[If you've had (and remember) a statistics course the output will make sense to you. The table of coefficients gives the estimated regression\nline as $r_{max} = 1.581 + 0.014 \\times Light$, and associated with each coefficient is the standard error of the estimate, the $t$-statistic value for testing whether the coefficient is nonzero, and the $p$-value corresponding to the $t$-statistic. Below the table, the adjusted R-squared gives the estimated fraction of the variance explained by the regression line, and the $p$-value in the last line is an overall test for significance of the model against the null hypothesis that the response variable is independent of the predictors.]\n\nYou can add the regression line to the plot of the data with a function taking `fit` as its input (if you closed the plot of the data, you will need to create it again in order to add the regression line):\n\n::: {.cell hash='no_solution_cache/html/unnamed-chunk-20_f01e2e56203859305859a5df5962043c'}\n\n```{.r .cell-code}\nabline(fit)\n```\n:::\n\n(`abline`, pronounced \"a b line\", is a general-purpose function for adding lines to a plot: you can specify horizontal or vertical lines, a slope and an intercept, or a regression model: `?abline`).\n\n\n::: {.cell fig='true' hash='no_solution_cache/html/unnamed-chunk-21_02cb4edb0a2ae280a23280e94df1f8ec'}\n::: {.cell-output-display}\n![Graphical summary of regression analysis](no_solution_files/figure-html/unnamed-chunk-21-1.png){width=384}\n:::\n:::\n\n\nYou can get the coefficients by using the `coef` function:\n\n::: {.cell hash='no_solution_cache/html/unnamed-chunk-22_cc72a1180b45a1844e3c5b3d7c4061e2'}\n\n```{.r .cell-code}\ncoef(fit)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(Intercept)       Light \n 1.58095214  0.01361776 \n```\n:::\n:::\n\n\nYou can also \"interrogate\" `fit` directly. Type `names(fit)` to get a list of the components of `fit`, and then use the `$` symbol to extract components according to their names.\n\n\n::: {.cell hash='no_solution_cache/html/unnamed-chunk-23_9b6cf78b07c81a7cb0975a033ae0220c'}\n\n```{.r .cell-code}\nnames(fit)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"coefficients\"  \"residuals\"     \"effects\"       \"rank\"         \n [5] \"fitted.values\" \"assign\"        \"qr\"            \"df.residual\"  \n [9] \"xlevels\"       \"call\"          \"terms\"         \"model\"        \n```\n:::\n:::\n\n\nFor more information (perhaps more than you want) about `fit`, use `str(fit)` (for **str**ucture). You can get the regression coefficients this way:\n\n\n::: {.cell hash='no_solution_cache/html/unnamed-chunk-24_411768c58d5a292847552d841f149f43'}\n\n```{.r .cell-code}\nfit$coefficients\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(Intercept)       Light \n 1.58095214  0.01361776 \n```\n:::\n:::\n\n\nIt's good to be able to look inside `R` objects when necessary, but all other things being equal you should prefer (e.g.) `coef(x)` to `x$coefficients`.\n\nUsually data is loaded from a file. To illustrate this, grab `Intro2.R` and `ChlorellaGrowth.txt` from brighspace to see how this is done. In `ChlorellaGrowth.txt` the two variables are entered as columns of a data matrix. Then instead of typing these in by hand, the command\n\n\n::: {.cell hash='no_solution_cache/html/unnamed-chunk-25_05d63e19d74671a8e6be1c940211a3be'}\n\n```{.r .cell-code}\nX=read.table(\"ChlorellaGrowth.txt\",header=TRUE)\n```\n:::\n\n\nreads the file (**from the current directory**) and puts the data values into the variable `X`; `header=TRUE` specifies that the file includes column names. **Note** that as specified above you need to make sure that `R` is looking for the data file in the right place ... either move the data file to your current working directory, or change the line so that it points to the actual location of the data file.\n\nExtract the variables from `X` with the commands\n\n\n::: {.cell hash='no_solution_cache/html/unnamed-chunk-26_7ae8c0928379c348dbc9983e1ad1c940'}\n\n```{.r .cell-code}\nLight=X[,1]\nrmax=X[,2]\n```\n:::\n\n\nThink of these as shorthand for \"`Light` = everything in column 1 of `X`\", and \"`rmax` = everything in column 2 of `X`\" (we'll learn about working with data matrices later). From there on out it's the same as before, with some additions that set the axis labels and add a title.\n\n::: {.cell type='exercisebox' latex.options='{1}' hash='no_solution_cache/html/unnamed-chunk-27_c79eef52c11cbd3b413880de9fd011ea'}\n\\BeginKnitrBlock{exercisebox}\\iffalse{-123-49-125-}\\fi{}<div class=\"exercisebox\">Make a copy of `Intro2.R` under a new name, and modify the copy so that it does linear regression of algal growth rate on the natural log of light intensity, `LogLight=log(Light)`, and plots the data appropriately. You should end up with  a graph that resembles Figure 3.\n\n\n*Hint:* when you switch from light intensity to log light intensity, the range on your $x$ axis will change and you will have to change the $x$ position at which you plot the growth rate equation.</div>\\EndKnitrBlock{exercisebox}\n:::\n\n\n::: {.cell type='solutionbox' latex.options='{1}' hash='no_solution_cache/html/unnamed-chunk-28_ae3d2753662537d05e80f7e4046e7c1a'}\n\n:::\n\n\n\n::: {.cell fig='true' hash='no_solution_cache/html/unnamed-chunk-29_caa6bae3fad46ff37edb564f3363f515'}\n::: {.cell-output-display}\n![Graphical summary of regression analysis, using log of light intensity (and annotating the plot)](no_solution_files/figure-html/unnamed-chunk-29-1.png){width=432}\n:::\n:::\n\n\n::: {.cell type='exercisebox' latex.options='{1}' hash='no_solution_cache/html/unnamed-chunk-30_9bfed34dd7e235877d212e6599aff21c'}\n\\BeginKnitrBlock{exercisebox}\\iffalse{-123-49-125-}\\fi{}<div class=\"exercisebox\">Run `Intro2.R`, then enter the command `plot(fit)` in the console and follow the directions in the console. Figure out what just happened.</div>\\EndKnitrBlock{exercisebox}\n:::\n\n::: {.cell type='solutionbox' latex.options='{1}' hash='no_solution_cache/html/unnamed-chunk-31_662dc506af7b0190ad00023007088ab8'}\n\n:::\n\n\n\nR produced a series of diagnostic plots exploring whether or not the fitted linear model is a suitable fit to the data. In each of the plots, the 3 most extreme points (the most likely candidates for \"outliers\") have been identified according to their sequence in the data set. \n\n\nThe axes in plots are scaled automatically,  but the outcome is not always ideal (e.g. if you want several graphs with exactly the same axis limits).  You can use the `xlim` and `ylim` arguments in `plot` to control the limits:\n`plot(x,y,xlim=c(x1,x2), [other stuff])`\n\nwill draw the graph with the $x$-axis running from `x1` to `x2`, and using `ylim=c(y1,y2)` within the `plot` command will do the same for the $y$-axis.\n\n::: {.cell type='exercisebox' latex.options='{1}' hash='no_solution_cache/html/unnamed-chunk-32_f647ab87d26d22402d09917c32c7ed12'}\n\\BeginKnitrBlock{exercisebox}\\iffalse{-123-49-125-}\\fi{}<div class=\"exercisebox\">Create a plot of growth rate versus light intensity with the $x$-axis running from 0 to 120 and the $y$-axis running from 1 to 4.</div>\\EndKnitrBlock{exercisebox}\n:::\n\n\n::: {.cell type='solutionbox' latex.options='{1}' hash='no_solution_cache/html/unnamed-chunk-33_fe206beb9503b935cae66454992f02c8'}\n\n:::\n\n\nYou can place several graphs within a single figure by using the `par` function (short for \"parameter\") to adjust the layout of the plot. For example, the command\n\n\n::: {.cell hash='no_solution_cache/html/unnamed-chunk-34_2ef95e6013198c6241bb1dd0bc2cc113'}\n\n```{.r .cell-code}\npar(mfrow=c(2,3))\n```\n:::\n\n\ndivides the plotting area into 2 rows and 3 columns. As  `R` draws a series of graphs, it places them along the top row from left to right, then along the next row, and so on. `mfcol=c(2,3)` has the same effect except that `R` draws successive graphs down the first column, then down the second column, and so on.\n\n::: {.cell type='exercisebox' latex.options='{1}' hash='no_solution_cache/html/unnamed-chunk-35_96d74014be4a9beffa3ec3ca0b45d17d'}\n\\BeginKnitrBlock{exercisebox}\\iffalse{-123-49-125-}\\fi{}<div class=\"exercisebox\">Modify the script as follows. Use `mfcol=c(2,1)` to create graphs of growth rate as a  function of `Light`, and of `log(growth rate)` as a function of `log(Light)` in the same figure. Do the same again, using `mfcol=c(1,2)`.</div>\\EndKnitrBlock{exercisebox}\n:::\n\n::: {.cell type='solutionbox' latex.options='{1}' hash='no_solution_cache/html/unnamed-chunk-36_52db592575be1cc4ce40e4a836829e6e'}\n\n:::\n\n::: {.cell type='exercisebox' latex.options='{1}' hash='no_solution_cache/html/unnamed-chunk-37_1888e62634c0ac82d35f90674f29cd90'}\n\\BeginKnitrBlock{exercisebox}\\iffalse{-123-49-125-}\\fi{}<div class=\"exercisebox\">Use `?par` to read about other plot control parameters that you use `par` to set (you should definitely skim --- this is one of the longest help files in the whole R system!).  Then draw a $2 \\times 2$ set of plots, each showing the line $y=5x+3$ with $x$ running from 3 to 8, but with 4 different line styles and 4 different line colors.</div>\\EndKnitrBlock{exercisebox}\n:::\n\n::: {.cell type='solutionbox' latex.options='{1}' hash='no_solution_cache/html/unnamed-chunk-38_712d3f95a6c38031c9c5c8c2bac55b93'}\n\n:::\n\n::: {.cell type='exercisebox' latex.options='{1}' hash='no_solution_cache/html/unnamed-chunk-39_e19f9f33fb909865892a25ce8bf5b38e'}\n\\BeginKnitrBlock{exercisebox}\\iffalse{-123-49-125-}\\fi{}<div class=\"exercisebox\">Modify one of your scripts so that at the very end it saves the plot to disk. In Windows you can do this with specific functions like `jpeg` or `png`.  Use `?jpeg` or `?png` to read about these functions.  Note that the argument `filename` can include the path to a folder; for example, in Windows you can use `filename=\"c:/temp/Intro2Figure\".` </div>\\EndKnitrBlock{exercisebox}\n:::\n\n::: {.cell type='solutionbox' latex.options='{1}' hash='no_solution_cache/html/unnamed-chunk-40_f52dd20790abfbeaee1ae811cf2a31fe'}\n\n:::\n\n\n::: {.cell type='exercisebox' latex.options='{1}' hash='no_solution_cache/html/unnamed-chunk-41_37048df8610e3fe416796dc82a0a6e06'}\n\\BeginKnitrBlock{exercisebox}\\iffalse{-123-49-125-}\\fi{}<div class=\"exercisebox\">Use google to see how to:\n  - rotate the y-axis labels\n  - change the background of the plot to grey</div>\\EndKnitrBlock{exercisebox}\n:::\n\n\n::: {.cell type='solutionbox' latex.options='{1}' hash='no_solution_cache/html/unnamed-chunk-42_c498041433dbbaad2fe2abad9b0b580d'}\n\n:::\n\n\n# Data types\n`R` distinguishes a number of data types including vectors, matrices, data frames and lists that each have special properties and which are used for calculations and data storage.\n\n## Vectors\nAn important class of data types are vectors and matrices (1- and 2-dimensional rectangular arrays of numbers). Operations with vectors and matrices may seem a bit abstract now, but we need them to do useful things later. The only properties of vectors are their type (or *class*) and length, although they can also have an associated list of names.\n\nWe've already seen two ways to create vectors in `R`:\n\n1. A command in the console window or a script file listing the values,\nsuch as\n\n::: {.cell hash='no_solution_cache/html/unnamed-chunk-43_67a9078a09c9da9f6c547cf77b890b17'}\n\n```{.r .cell-code}\ninitialsize=c(1,3,5,7,9,11)\n```\n:::\n\n\n2. Using `read.table`:\n\n  ::: {.cell hash='no_solution_cache/html/unnamed-chunk-44_b7eed5b62759ecad5b6a2b5e3f5e2a4f'}\n  \n  ```{.r .cell-code}\n  initialsize=read.table(\"c:/temp/initialdata.txt\")\n  ```\n  :::\n\n  (assuming of course that the file exists in the right place).\n\n  You can then use a vector in calculations as if it were a number (more or less)\n\n  ::: {.cell hash='no_solution_cache/html/unnamed-chunk-45_7788e078c9525fe0fc341a357c17ef6e'}\n  \n  ```{.r .cell-code}\n  finalsize=initialsize+1\n  finalsize\n  ```\n  \n  ::: {.cell-output .cell-output-stdout}\n  ```\n  [1]  2  4  6  8 10 12\n  ```\n  :::\n  \n  ```{.r .cell-code}\n  newsize=sqrt(initialsize)\n  newsize\n  ```\n  \n  ::: {.cell-output .cell-output-stdout}\n  ```\n  [1] 1.000000 1.732051 2.236068 2.645751 3.000000 3.316625\n  ```\n  :::\n  :::\n\n\nNotice that `R` applied each operation to every element in the vector. Similarly, commands like `initialsize-5, 2*initialsize, initialsize/10` apply subtraction, multiplication, and division to each element of the\nvector. The same is true for\n\n::: {.cell hash='no_solution_cache/html/unnamed-chunk-46_35289f54bfeae1105ce6a9334795ac21'}\n\n```{.r .cell-code}\ninitialsize^2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]   1   9  25  49  81 121\n```\n:::\n:::\n\n\nIn `R` the default is to apply functions and operations to vectors in an *element by element* (or \"vectorized\") manner. This is an extremely useful propery in `R`.\n\n### Functions for creating vectors\n\nYou can use the `seq` function to create a set of regularly spaced values. `seq`'s syntax is `x=seq(from,to,by)` or `x=seq(from,to)` or `x=seq(from,to,length.out)`.\nThe first form generates a vector starting with `from` with the last entry not extending further than than `to` in steps of `by`. In the second form the value of `by` is assumed to be 1 or -1, depending on\nwhether `from` or `to` is larger. The third form creates a vector with the desired endpoints and length. The syntax `from:to` is a shortcut for `seq(from,to)`:\n\n::: {.cell hash='no_solution_cache/html/unnamed-chunk-47_77e2c6acbd159cebee697ee8e0f14612'}\n\n```{.r .cell-code}\n1:8\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3 4 5 6 7 8\n```\n:::\n:::\n\n\n::: {.cell type='exercisebox' latex.options='{1}' hash='no_solution_cache/html/unnamed-chunk-48_a6a4ebb8f19e9054a458dbf9d17b1ef8'}\n\\BeginKnitrBlock{exercisebox}\\iffalse{-123-49-125-}\\fi{}<div class=\"exercisebox\">Use `seq` to create the vector `v=(1 5 9 13)`, and to create a vector going from 1 to 5 in increments of 0.2.</div>\\EndKnitrBlock{exercisebox}\n:::\n\n::: {.cell type='solutionbox' latex.options='{1}' hash='no_solution_cache/html/unnamed-chunk-49_55227356678bee2675b9e565127677c8'}\n\n:::\n\nYou can use `rep` to create a constant vector such as `(1 1 1 1)`; the basic syntax is `rep(values,lengths)`. For example,\n\n::: {.cell hash='no_solution_cache/html/unnamed-chunk-50_3df7d1e2d5f9075ca1754d295473437a'}\n\n```{.r .cell-code}\nrep(3,5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3 3 3 3 3\n```\n:::\n:::\n\ncreates a vector in which the value 3 is repeated 5 times. `rep` will repeat a whole vector multiple times\n\n::: {.cell hash='no_solution_cache/html/unnamed-chunk-51_b0c045d781ba6a0cb5217145d0e3e515'}\n\n```{.r .cell-code}\nrep(1:3,3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3 1 2 3 1 2 3\n```\n:::\n:::\n\nor will repeat each of the elements in a vector a given number of times:\n\n::: {.cell hash='no_solution_cache/html/unnamed-chunk-52_7fe599583b2b5553f2e7874b00eaed90'}\n\n```{.r .cell-code}\nrep(1:3,each=3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 1 1 2 2 2 3 3 3\n```\n:::\n:::\n\n\nEven more flexibly, you can repeat each element in the vector a different number of times:\n\n::: {.cell hash='no_solution_cache/html/chunk_50_f56be7fb6eee38ea461030859a9df736'}\n\n```{.r .cell-code}\nrep( c(3,4),c(2,5) )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3 3 4 4 4 4 4\n```\n:::\n:::\n\nThe value 3 was repeated 2 times, followed by the value 4 repeated 5 times.\n`rep` can be a little bit mind-blowing as you get started, but it will turn out to be useful.\n\nTable 3 lists some of the main functions for creating and working with vectors.\n\n::: {.cell hash='no_solution_cache/html/unnamed-chunk-53_dd923e50b5b019a5444987787e7d566a'}\n::: {.cell-output-display}\n\\begin{table}\n\n\\caption{\\label{tab:unnamed-chunk-53}Some important `R` functions for creating and working with vectors. Many of these have other optional arguments; use the help system (e.g. \\texttt{?cor}) for more information. The statistical functions such as \\texttt{var} regard the values as samples from a population and compute an estimate of the population statistic; for example \\texttt{sd(1:3)=1}.}\n\\centering\n\\resizebox{\\linewidth}{!}{\n\\begin{tabular}[t]{ll}\n\\toprule\nFunction & Definition\\\\\n\\midrule\n\\texttt{seq(from,to,by=1)} & Vector of evenly spaced values, default increment = 1\\\\\n\\texttt{seq(from, to, length.out)} & Vector of evenly spaced values, specified length\\\\\n\\texttt{c(u,v,...)} & Combine a set of numbers and/or vectors into a single vector\\\\\n\\texttt{rep(a,b)} & Create vector by repeating elements of \\texttt{a} by amounts in \\texttt{b}\\\\\n\\texttt{as.vector(x)} & Convert an object of some other type to a vector\\\\\n\\addlinespace\n\\texttt{hist(v)} & Histogram plot of value in v\\\\\n\\texttt{mean(v),var(v),sd(v)} & Estimate of population mean, variance, standard deviation\\\\\n & based on data values in \\texttt{v}\\\\\n\\texttt{cor(v,w)} & Correlation between two vectors\\\\\n\\bottomrule\n\\end{tabular}}\n\\end{table}\n:::\n:::\n\n\n### Vector indexing\n\nYou will often want to extract a specific entry or other part of a vector. This procedure is called *vector indexing*, and uses square brackets (`[]`):\n\n::: {.cell hash='no_solution_cache/html/unnamed-chunk-54_8fca868ec648a66c5db13b50ebff5c77'}\n\n```{.r .cell-code}\nz=c(1,3,5,7,9,11)\nz[3]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5\n```\n:::\n:::\n\n\n`z[3]` extracts the third item, or *element*, in the vector `z`.\nYou can also access a block of elements using the functions for\nvector construction, e.g.\n\n::: {.cell hash='no_solution_cache/html/unnamed-chunk-55_74ee3132580915a6d18ff1565306bfed'}\n\n```{.r .cell-code}\nz[2:5]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3 5 7 9\n```\n:::\n:::\n\nextracts the second through fifth elements.\n\nWhat happens if you enter `v=z[seq(1,5,2)]` ? Try it and see, and make sure you understand what happened.\n\nYou can extracted irregularly spaced elements of a vector. For example\n\n::: {.cell hash='no_solution_cache/html/unnamed-chunk-56_19edfc5c279aec512645ce3074236547'}\n\n```{.r .cell-code}\nz[c(1,2,5)]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 3 9\n```\n:::\n:::\n\n\nYou can also use indexing to **set specific values within a vector**. For\nexample,\n\n::: {.cell hash='no_solution_cache/html/unnamed-chunk-57_39c99116708ec7421aa6bccb6498fd4b'}\n\n```{.r .cell-code}\nz[1]=12\n```\n:::\n\nchanges the value of the first entry in `z` while leaving all the rest alone, and\n\n::: {.cell hash='no_solution_cache/html/unnamed-chunk-58_9eea72a3322a89b1c4150d09b5dc0f1b'}\n\n```{.r .cell-code}\nz[c(1,3,5)]=c(22,33,44)\n```\n:::\n\nchanges the first, third, and fifth values (note that we had to use `c` to create the vector --- can you interpret the error message you get if you\ntry `z[1,3,5]` ?)\n\n::: {.cell type='exercisebox' latex.options='{1}' hash='no_solution_cache/html/unnamed-chunk-59_c559f6d123959b251398a4e2e9b30bad'}\n\\BeginKnitrBlock{exercisebox}\\iffalse{-123-49-125-}\\fi{}<div class=\"exercisebox\">Write a *one-line* command to extract a vector consisting of the second, first, and third elements of `z` *in that order*.</div>\\EndKnitrBlock{exercisebox}\n:::\n\n::: {.cell type='solutionbox' latex.options='{1}' hash='no_solution_cache/html/unnamed-chunk-60_f7b1d8967575f1228c49ff5240ff0a10'}\n\n:::\n\n\n::: {.cell type='exercisebox' latex.options='{1}' hash='no_solution_cache/html/unnamed-chunk-61_5044d1a8d56222b9d07f7f0c49f4aab7'}\n\\BeginKnitrBlock{exercisebox}\\iffalse{-123-49-125-}\\fi{}<div class=\"exercisebox\">Write a script file that computes values of\n$y=\\frac{(x-1)}{(x+1)}$ for $x=1,2,\\cdots,10$, and plots $y$ versus $x$\nwith the points plotted and connected by a line \n*hint:* in `?plot`, search for `type`).</div>\\EndKnitrBlock{exercisebox}\n:::\n\n\n::: {.cell type='solutionbox' latex.options='{1}' hash='no_solution_cache/html/unnamed-chunk-62_d63cd0fb9f6739d5f7d56522540723b0'}\n\n:::\n\nThe sum of the geometric series $1 + r + r^2 + r^3 + ... + r^n$ approaches the limit $1/(1-r)$ for $r < 1$ as $n \\rightarrow \\infty$.\n\n\n::: {.cell type='exercisebox' latex.options='{1}' hash='no_solution_cache/html/unnamed-chunk-63_a2ca9a321d998966ac03b62b5e3c4721'}\n\\BeginKnitrBlock{exercisebox}\\iffalse{-123-49-125-}\\fi{}<div class=\"exercisebox\">Set the values $r=0.5$ and $n=10$, and then write a *one-line* command that creates the vector $G = (r^0,r^1,r^2,...,r^n)$. Compare the sum (using `sum`) of this vector to the limiting value $1/(1-r)$. \n\nRepeat for  $n=50$. (*Note* that comparing very similar numeric values can be tricky: rounding can happen, and some numbers cannot be represented exactly in binary (computer) notation. By default `R` displays 7~significant digits (`options(\"digits\")`).</div>\\EndKnitrBlock{exercisebox}\n:::\n\n::: {.cell type='solutionbox' latex.options='{1}' hash='no_solution_cache/html/unnamed-chunk-64_f8a1db0657a1b9043bc7596a4de3a636'}\n\n:::\nFor example:\n\n::: {.cell hash='no_solution_cache/html/unnamed-chunk-65_c5a4fa2b6f6a4afd44c04914fdba9686'}\n\n```{.r .cell-code}\nx = 1.999999\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1.999999\n```\n:::\n\n```{.r .cell-code}\nx-2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] -1e-06\n```\n:::\n\n```{.r .cell-code}\nx=1.9999999999999\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2\n```\n:::\n\n```{.r .cell-code}\nx-2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] -9.992007e-14\n```\n:::\n:::\n\nAll the digits are still there, in the second case, but they are not shown.\nAlso note that `x-2` is not exactly $-1 \\times 10^{-13}$; this is unavoidable.)\n\n### Logical operators\nLogical operators return a value of `TRUE` or `FALSE`. For example,\ntry:\n\n::: {.cell hash='no_solution_cache/html/unnamed-chunk-66_0009dde973df81efea5e8049b96e547d'}\n\n```{.r .cell-code}\na=1\nb=3\nd=a<b\ne=(a>b)\nd\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\ne\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n:::\n\n\nThe parentheses around (`a>b`) are optional but make the code easier to read.\nOne special case where you *do* need parentheses (or spaces) is when you make comparisons with negative values; `a<-1` will surprise you by setting `a=1`,\nbecause `<-` (representing a left-pointing arrow) is equivalent to `=` in `R`. Use `a< -1`, or more safely `a<(-1)`, to make this comparison.\n\n::: {.cell hash='no_solution_cache/html/unnamed-chunk-67_f5c2a016ea52b028358fa1f108ccbf00'}\n::: {.cell-output-display}\n\\begin{table}\n\n\\caption{\\label{tab:unnamed-chunk-67}Some comparison operators in `R`. Use \\texttt{?Comparison} to learn more.}\n\\centering\n\\begin{tabular}[t]{ll}\n\\toprule\nOperator & Definition\\\\\n\\midrule\n\\texttt{x<y} & less than\\\\\n\\texttt{x>y} & greater than\\\\\n\\texttt{x<=y} & less than or equal to\\\\\n\\texttt{x>=y} & greater than or equal to\\\\\n\\texttt{x==y} & equal to\\\\\n\\addlinespace\n\\texttt{x!=y} & \\emph{not} equal to\\\\\n\\bottomrule\n\\end{tabular}\n\\end{table}\n:::\n:::\n\n\nWhen we compare two vectors or matrices of the same size, or compare a\nnumber with a vector or matrix, comparisons are done element-by-element.\nFor example,\n\n\n::: {.cell hash='no_solution_cache/html/unnamed-chunk-68_0f3212eaa93db7d741972092977b01db'}\n\n```{.r .cell-code}\nx=1:5\nb=(x<=3)\n```\n:::\n\n\nSo if `x` and `y` are vectors, then `(x==y)` will return a vector of values giving the element-by-element comparisons. If you want to know whether `x` and `y` are identical vectors, use `identical(x,y)` which returns a single value: `TRUE` if each entry in `x` equals the corresponding entry in `y`, otherwise `FALSE`. You can use `?Logical` to read more about logical operators. Note the difference between = and == \n\n::: {.cell type='exercisebox' latex.options='{1}' hash='no_solution_cache/html/unnamed-chunk-69_ba0bcb50caed18cfface024d119f1f3e'}\n\\BeginKnitrBlock{exercisebox}\\iffalse{-123-49-125-}\\fi{}<div class=\"exercisebox\">Can you figure out what happened in the following cautionary tale below?</div>\\EndKnitrBlock{exercisebox}\n:::\n\n\n\n::: {.cell hash='no_solution_cache/html/unnamed-chunk-70_21cd18d25aa10ab17063d0b91c779fde'}\n\n```{.r .cell-code}\na = 1:3\nb = 2:4\na==b\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE FALSE FALSE\n```\n:::\n\n```{.r .cell-code}\na=b\na==b\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE TRUE TRUE\n```\n:::\n:::\n\n\n\n::: {.cell type='solutionbox' latex.options='{1}' hash='no_solution_cache/html/unnamed-chunk-71_a54e0421b5a68268e36a2db35daa74d7'}\n\n:::\n\n\n\nExclamation points `!` are used in `R` to mean \"not\"; `!=` (not `==`) means \"not equal to\".\n\n`R` also does arithmetic on logical values, treating `TRUE` as 1 and `FALSE` as 0. So `sum(b)` returns the value 3, telling us that three entries of `x` satisfied the condition (`x<=3`). This is useful for (e.g.) seeing how many of the elements of a vector are larger than a cutoff value. Build more complicated conditions by using *logical operators* to combine comparisons:\n\n* `!`: Negation\n* `&`, `&&`: AND\n* `|`, `||`: OR\n\nOR is *non-exclusive*, meaning that `x|y` is true  if either `x` or `y` *or both* are true (a ham-and-cheese sandwich would satisfy the condition \"ham OR cheese\"). For example, try\n\n::: {.cell hash='no_solution_cache/html/unnamed-chunk-72_e979fa4c9ed4eef1951febb392d0ed3c'}\n\n```{.r .cell-code}\na=c(1,2,3,4)\nb=c(1,1,5,5)\n(a<b)& (a>3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE FALSE FALSE  TRUE\n```\n:::\n\n```{.r .cell-code}\n(a<b) | (a>3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE FALSE  TRUE  TRUE\n```\n:::\n:::\n\nand make sure you understand what happened. If it's confusing, try breaking up the expression\nand looking at the results of `a<b` and `a>3` separately first. The two forms of AND and OR differ in how they handle vectors. The shorter one does element-by-element comparisons; the longer one only looks at the\nfirst element in each vector.\n\nWe can also use *logical* vectors (lists of `TRUE` and `FALSE` values) to pick elements out of vectors.\nThis is important, e.g., for subsetting data (getting rid of those pesky outliers!)\n\nAs a simple example, we might want to focus on just the low-light values of $r_{max}$ in the *Chlorella* example:\n\n::: {.cell hash='no_solution_cache/html/unnamed-chunk-73_f8e8b25ad6408b32388ee9278c4271f5'}\n\n```{.r .cell-code}\nX=read.table(\"ChlorellaGrowth.txt\",header=TRUE)\nLight=X[,1]\nrmax=X[,2]\nlowLight = Light[Light<50]\nlowLightrmax = rmax[Light<50]\nlowLight\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 20 20 20 20 21 24 44\n```\n:::\n\n```{.r .cell-code}\nlowLightrmax\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1.73 1.65 2.02 1.89 2.61 1.36 2.37\n```\n:::\n:::\n\n\nWhat is really happening here (think about it for a minute) is that `Light<50` generates a logical vector the same length as `Light` (`TRUE TRUE TRUE ...`) which is then used to select the appropriate\nvalues.\n\nIf you want the positions at which `Light` is lower than 50, you could say\n`(1:length(Light))[Light<50]`, but you can also use a built-in function: `which(Light<50)`. If you wanted the position at which the maximum value\nof `Light` occurs, you could say `which(Light==max(Light))`. (This normally results in a vector of length 1; when could it give a longer vector?) There is even a built-in command for this specific function, `which.max` (although `which.max` always returns just the *first* position at which the maximum occurs).\n\n::: {.cell type='exercisebox' latex.options='{1}' hash='no_solution_cache/html/unnamed-chunk-74_a8af8c4c60e8e08fd5ca51346106f411'}\n\\BeginKnitrBlock{exercisebox}\\iffalse{-123-49-125-}\\fi{}<div class=\"exercisebox\">What would happen if instead of setting `lowLight` you replaced `Light` by saying `Light=Light[Light<50]`, and then `rmax=rmax[Light<50]`? \n\nWhy would that be wrong? \n\nTry it with some temporary variables --- set `Light2=Light` and `rmax2=rmax` and then play with `Light2` and `rmax2` so you dont mess up your working variables --- and work out what happened ...</div>\\EndKnitrBlock{exercisebox}\n:::\n\n\n::: {.cell type='solutionbox' latex.options='{1}' hash='no_solution_cache/html/unnamed-chunk-75_9cd81bfbc7ac9243c03c888dbd6183bd'}\n\n:::\n\nWe can also combine logical operators (making sure to use the element-by-element `&` and `|` versions of AND and OR):\n\n::: {.cell hash='no_solution_cache/html/unnamed-chunk-76_48bd81c3b091a6b6da6359c248a1fc9d'}\n\n```{.r .cell-code}\nLight[Light<50 & rmax <= 2.0]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 20 20 20 24\n```\n:::\n\n```{.r .cell-code}\nrmax[Light<50 & rmax <= 2.0]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1.73 1.65 1.89 1.36\n```\n:::\n:::\n\n\n::: {.cell type='exercisebox' latex.options='{1}' hash='no_solution_cache/html/unnamed-chunk-77_d1db1fa391895387fb64637c1554e501'}\n\\BeginKnitrBlock{exercisebox}\\iffalse{-123-49-125-}\\fi{}<div class=\"exercisebox\">`runif(n)` is a function (more on it soon) that generates a vector of `n` random, uniformly distributed\nnumbers between 0 and 1. Create a vector of 20 numbers, then select the subset of those numbers that\nis less than the mean. (If you want your answers to match mine exactly, use `set.seed(273)` to set the random-number generator to a particular starting point before you use `runif`. [273 is an arbitrary number I chose].)</div>\\EndKnitrBlock{exercisebox}\n:::\n\n\n::: {.cell type='solutionbox' latex.options='{1}' hash='no_solution_cache/html/unnamed-chunk-78_70f07f9f74bc1fdce6f784f82fa9db2e'}\n\n:::\n\n::: {.cell type='exercisebox' latex.options='{1}' hash='no_solution_cache/html/unnamed-chunk-79_b30cee3e54d7bf1fc8394875f770b553'}\n\\BeginKnitrBlock{exercisebox}\\iffalse{-123-49-125-}\\fi{}<div class=\"exercisebox\">Find the *positions*  of the elements that are less than the mean of the vector you just created (e.g. if your vector were `(0.1 0.9. 0.7 0.3)` the answer would be `(1 4)`).</div>\\EndKnitrBlock{exercisebox}\n:::\n\n\n\n::: {.cell type='solutionbox' latex.options='{1}' hash='no_solution_cache/html/unnamed-chunk-80_4f07f6a9b9b00e2ae5c2dd4744f47428'}\n\n:::\n\nAs I mentioned in passing above, vectors can have names associated with their elements: if they do, you can also extract elements by name (use `names` to find out the names).\n\n\n::: {.cell hash='no_solution_cache/html/unnamed-chunk-81_a317c1357dd510f85b95d83001f54de8'}\n\n```{.r .cell-code}\nx = c(first=7,second=5,third=2)\nnames(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"first\"  \"second\" \"third\" \n```\n:::\n\n```{.r .cell-code}\nx[\"first\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nfirst \n    7 \n```\n:::\n\n```{.r .cell-code}\nx[c(\"third\",\"first\")]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nthird first \n    2     7 \n```\n:::\n:::\n\n\nFinally, it is sometimes handy to be able to drop a particular set of elements, rather than taking a particular set: you can do this with negative indices. For example, `x[-1]` extracts all but the first\nelement of a vector.\n\n::: {.cell type='exercisebox' latex.options='{1}' hash='no_solution_cache/html/unnamed-chunk-82_facbd73f094ae5a329795ab362816f1d'}\n\\BeginKnitrBlock{exercisebox}\\iffalse{-123-49-125-}\\fi{}<div class=\"exercisebox\">Specify two ways to take only the elements in the odd positions (first, third, ...) of a vector of arbitrary length.</div>\\EndKnitrBlock{exercisebox}\n:::\n\n\n::: {.cell type='solutionbox' latex.options='{1}' hash='no_solution_cache/html/unnamed-chunk-83_b420843bba332f87a9d8e9f77e17ea1c'}\n\n:::\n\n## Matrices\n\n### Creating matrices\n\nA matrix is a two-dimensional array, and has the same kind of variables in every column. You can  create matrices of numbers by creating a vector of the matrix entries, and then reshaping them to the desired number of rows and columns using the function `matrix`. For example\n\n::: {.cell hash='no_solution_cache/html/unnamed-chunk-84_33ee40dd8c6ea2e9a5060cc18137d1b6'}\n\n```{.r .cell-code}\n(X=matrix(1:6,nrow=2,ncol=3))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    2    4    6\n```\n:::\n:::\n\ntakes the values 1 to 6 and reshapes them into a 2 by 3 matrix.\n\nBy default `R` loads the values into the matrix *column-wise* (this is probably counter-intuitive since we're used to reading tables row-wise). Use the optional parameter `byrow` to change this behavior.\nFor example :\n\n::: {.cell hash='no_solution_cache/html/unnamed-chunk-85_8d2462598b83bc3d6345faf31e4bc6b1'}\n\n```{.r .cell-code}\n(A=matrix(1:9,nrow=3,ncol=3,byrow=TRUE))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    1    2    3\n[2,]    4    5    6\n[3,]    7    8    9\n```\n:::\n:::\n\n\n`R` will re-cycle through entries in the data vector, if necessary to fill a matrix of the specified size. So for example\n\n::: {.cell hash='no_solution_cache/html/unnamed-chunk-86_d38e00a79de14d7c242f0a149cc3dff6'}\n\n```{.r .cell-code}\nmatrix(1,nrow=10,ncol=10)\n```\n:::\n\ncreates a $10 \\times 10$ matrix of ones.\n\n::: {.cell type='exercisebox' latex.options='{1}' hash='no_solution_cache/html/unnamed-chunk-87_ca824ccff7a288cb30120e27e2d6a5eb'}\n\\BeginKnitrBlock{exercisebox}\\iffalse{-123-49-125-}\\fi{}<div class=\"exercisebox\">Use a command of the form `X=matrix(v,nrow=2,ncol=4)` where `v` is a data vector, to create the following matrix `X`:</div>\\EndKnitrBlock{exercisebox}\n:::\n\n\n::: {.cell type='solutionbox' latex.options='{1}' hash='no_solution_cache/html/unnamed-chunk-88_ad85dba8c666095809d0b5286ea7b475'}\n\n:::\n\n\n::: {.cell hash='no_solution_cache/html/unnamed-chunk-89_cc4ea7e74bad56701b6a40261e886b55'}\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3] [,4]\n[1,]    1    1    1    1\n[2,]    2    2    2    2\n```\n:::\n:::\n\nIf you can, try to use `R` commands to construct the vector rather than typing out all of the individual values.\n\n`R` will also collapse a matrix to behave like a vector whenever it makes sense: for example `sum(X)` above is 12.\n\n::: {.cell type='exercisebox' latex.options='{1}' hash='no_solution_cache/html/unnamed-chunk-90_8a47541fcc446a6a58f6899c90d5f786'}\n\\BeginKnitrBlock{exercisebox}\\iffalse{-123-49-125-}\\fi{}<div class=\"exercisebox\">Use `rnorm` (which is like `runif`, but generates Gaussian (normally distributed) numbers with a specified mean and standard deviation instead) and `matrix` to create a $5 \\times 7$ matrix of Gaussian random numbers with mean 1 and standard deviation 2. (Use `set.seed(273)` again for consistency.)</div>\\EndKnitrBlock{exercisebox}\n:::\n\n\n\n::: {.cell type='solutionbox' latex.options='{1}' hash='no_solution_cache/html/unnamed-chunk-91_d1095cff07beeb9f6d78bf97d3126e65'}\n\n:::\n\nAnother useful function for creating matrices is `diag`. `diag(v,n)` creates an $n \\times n$ matrix with data\nvector $v$ on its diagonal. So for example `diag(1,5)` creates the $5 \\times 5$ *identity matrix*, which has 1's on the diagonal and 0 everywhere else. Try `diag(1:5,5)` and `diag(1:2,5)`; why does the latter produce a warning?\n\nFinally, you can use the `data.entry` function. This function can only edit existing matrices, but for example \n\n::: {.cell hash='no_solution_cache/html/unnamed-chunk-92_35f96b9392232cc0389bb760bd99e622'}\n\n```{.r .cell-code}\nA=matrix(0,nrow=3,ncol=4)\ndata.entry(A)\n```\n:::\n\nwill create `A` as a $3 \\times 4$ matrix, and then call up a spreadsheet-like interface in which you can change the values to whatever you need.\n\n\n::: {.cell result='asis' hash='no_solution_cache/html/unnamed-chunk-93_708bf8d4bd902aca8100a6084ea6f44b'}\n::: {.cell-output-display}\n\\begin{table}\n\n\\caption{\\label{tab:unnamed-chunk-93}Some important functions for creating and working with matrices. Many of these have additional optional arguments; use the help system for full details.}\n\\centering\n\\resizebox{\\linewidth}{!}{\n\\begin{tabular}[t]{ll}\n\\toprule\nFunction & Definition\\\\\n\\midrule\n\\texttt{matrix(v,nrow=m,ncol=n)} & $m \\times n$ matrix using the values in \\texttt{v}\\\\\n\\texttt{t(A)} & transpose (exchange rows and columns) of matrix \\texttt{A}\\\\\n\\texttt{dim(X)} & dimensions of matrix X. \\texttt{dim(X)[1]} = number of rows,\\\\\n & \\texttt{dim(X)[2]} = number of columns\\\\\n\\texttt{data.entry(A)} & call up a spreadsheet-like interface to edit the values in \\texttt{A}\\\\\n\\addlinespace\n\\texttt{diag(v,n)} & diagonal $n \\times n$ matrix with $v$ on diagonal, 0 elsewhere\n(\\texttt{v} is 1 by default,\\\\\n & so \\texttt{diag(n)} gives an $n \\times n$ identity matrix)\\\\\n\\texttt{cbind(a,b,c,...)} & combine compatible objects by attaching them along columns\\\\\n\\texttt{rbind(a,b,c,...)} & combine compatible objects by attaching them along rows\\\\\n\\texttt{as.matrix(x)} & convert an object of some other type to a matrix, if possible\\\\\n\\addlinespace\n\\texttt{outer(v,w)} & \"outer product\" of vectors \\texttt{v}, \\texttt{w}: the matrix whose $(i,j)$th element is \\texttt{v[i]*w[j]}\\\\\n\\bottomrule\n\\end{tabular}}\n\\end{table}\n:::\n:::\n\n\n### `cbind` and `rbind`\nIf their sizes match, you can combine vectors to form matrices, and stick matrices together with vectors or other matrices. `cbind` (\"column bind\") and `rbind` (\"row bind\") are the functions to use.\n\n`cbind` binds together columns of two objects. One thing it can do is put vectors together to form a matrix:\n\n::: {.cell hash='no_solution_cache/html/chunk_101_c51dea298db92105507f03c5c26c4c40'}\n\n```{.r .cell-code}\n(C=cbind(1:3,4:6,5:7))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    1    4    5\n[2,]    2    5    6\n[3,]    3    6    7\n```\n:::\n:::\n\n`R` interprets vectors as row or column vectors according to what you're doing with them. Here it treats them as column vectors so that columns exist to be bound together. On the other hand,\n\n::: {.cell hash='no_solution_cache/html/unnamed-chunk-94_0091f60eb9857dca2708849943717a31'}\n\n```{.r .cell-code}\n(D=rbind(1:3,4:6))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    1    2    3\n[2,]    4    5    6\n```\n:::\n:::\n\ntreats them as rows. Now we have two matrices that can be combined.\n\n::: {.cell type='exercisebox' latex.options='{1}' hash='no_solution_cache/html/unnamed-chunk-95_be4545f4218d3a593f542f63760460cb'}\n\\BeginKnitrBlock{exercisebox}\\iffalse{-123-49-125-}\\fi{}<div class=\"exercisebox\">Verify that `rbind(C,D)` works, `cbind(C,C)` works, but `cbind(C,D)` doesn't. Why not?</div>\\EndKnitrBlock{exercisebox}\n:::\n\n::: {.cell type='solutionbox' latex.options='{1}' hash='no_solution_cache/html/unnamed-chunk-96_95807708276727d676c8552dca5a6526'}\n\n:::\n\n### Matrix indexing\n\nMatrix indexing is like vector indexing except that you have to specify both the row and column, or range of rows and columns. For example `z=A[2,3]` sets `z` equal to 6, which is the (2nd row, 3rd column) entry of the matrix **A** that you recently created, and\n\n::: {.cell hash='no_solution_cache/html/unnamed-chunk-97_c14e4875d235892ab97cdd6159e21bdf'}\n\n```{.r .cell-code}\nA[2,2:3]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5 6\n```\n:::\n\n```{.r .cell-code}\n(B=A[2:3,1:2])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2]\n[1,]    4    5\n[2,]    7    8\n```\n:::\n:::\n\n\nThere is an easy shortcut to extract entire rows or columns: leave out the limits, leaving a blank before or after the comma.\n\n::: {.cell hash='no_solution_cache/html/unnamed-chunk-98_4af68ba1e9b6325eff80bd392c1aafe8'}\n\n```{.r .cell-code}\n(first.row=A[1,])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3\n```\n:::\n\n```{.r .cell-code}\n(second.column=A[,2])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2 5 8\n```\n:::\n:::\n\n\n(What does `A[,]` do?)\n\nAs with vectors, indexing also works in reverse for assigning values to matrix entries. For example,\n\n::: {.cell hash='no_solution_cache/html/unnamed-chunk-99_19017d9b2da0de9b4aaf44ea321ba979'}\n\n```{.r .cell-code}\n(A[1,1]=12)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 12\n```\n:::\n:::\n\n\nYou can do the same with blocks, rows, or columns, for example\n\n::: {.cell hash='no_solution_cache/html/unnamed-chunk-100_667ede53b61efe369af802e21442e405'}\n\n```{.r .cell-code}\n(A[1,]=c(2,4,5))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2 4 5\n```\n:::\n:::\n\n\nIf you use `which` on a matrix, `R` will normally treat the matrix as a vector --- so for example `which(A==8)` will give the answer 6 (figure out why). However, `which` does have an option that will treat its argument\nas a matrix:\n\n::: {.cell hash='no_solution_cache/html/unnamed-chunk-101_3d45630e0fb35d38f25700731985c32d'}\n\n```{.r .cell-code}\nwhich(A==8,arr.ind=TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     row col\n[1,]   3   2\n```\n:::\n:::\n\n\n## Lists\n\nWhile vectors and matrices may seem familiar, lists are probably new to you. Vectors and matrices have to contain elements that are all the same type: lists in `R` can contain anything --- vectors, matrices,\nother lists ... Indexing lists is a little different too: use double square brackets `[[ ]]` (rather\nthan single square brackets as for a vector) to extract an element of a list by number or name, or `$` to extract an element by name (only). Given a list like this:\n\n\n::: {.cell hash='no_solution_cache/html/unnamed-chunk-102_478adad7796729c41729d9b57888a4ab'}\n\n```{.r .cell-code}\nL = list(A=x,B=y,C=c(\"a\",\"b\",\"c\"))\n```\n:::\n\n\nThen `L$A`, `L[[\"A\"]]`, and `L[[1]]` will all grab the first element of the list.\n\nYou won't use lists too much at the beginning, but many of `R`'s own results are structured in the form of lists.\n\n## Data frames\n\nData frames are the solution to the problem that most data sets have several different kinds of variables observed for each sample (e.g. categorical site location and continuous rainfall), but matrices can only contain a single type of data. Data frames are a hybrid of lists and vectors; internally, they are a list of vectors that may be of different types but must all be the same length, but you can do most of the same things with them (e.g., extracting a subset of rows) that you can do with matrices. You can index them either the way you would index a list, using `[[ ]]` or `$` --- where each variable is a different item in the list --- or the way you would index a matrix. Use `as.matrix` if you have a data frame (where all variables are the same type) that you really want to be a matrix, e.g. if you need to transpose it (use `as.data.frame` to go the other way).\n\n\n# References & Acknowlegdments\n\nThese notes are based in part on course materials by former TAs Colleen Webb, Jonathan Rowell and Daniel Fink at Cornell, Professors Lou Gross (University of Tennessee) and Paul Fackler (NC State University), and on the book *Getting Started with Matlab* by Rudra Pratap (Oxford University Press). They also draw on the documentation supplied with `R`. They parallel, but go into more depth than, the chapter supplement for the book *Ecological Models and Data in `R`*.\n\nYou can find many other similar introductions scattered around the web, or in the \"contributed documentation\" section on the `R` web site (http://cran.r-project.org/other-docs.html). This particular version is limited (it has similar coverage to Sections 1 and 2 of the *Introduction to `R`* that comes with `R`) and targets biologists who are neither programmers nor statisticians.\n\n\nFussmann, G., S. P. Ellner, K. W. Shertzer and J. N. G. Hairston. 2000. Crossing the Hopf bifurcation in a live predator-prey system. Science **290**:1358-1360.\n\nIhaka, `R`. and `R`. Gentleman. 1996. `R`: A language for data analysis and graphics. Journal of Computational and Graphical Statistics **5**:299-314.\n\nVenables and Ripley. 2002. Modern Applied Statistics with S. Springer, New York. 4th edition.\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}